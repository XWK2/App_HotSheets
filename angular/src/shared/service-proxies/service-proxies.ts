//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.1.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CatalogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getShortageShift(isActive: boolean | undefined): Observable<ShortageShiftDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetShortageShift?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortageShift(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortageShift(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShortageShiftDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShortageShiftDto[]>;
        }));
    }

    protected processGetShortageShift(response: HttpResponseBase): Observable<ShortageShiftDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ShortageShiftDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateShortageShift(body: ShortageShiftDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateShortageShift";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateShortageShift(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateShortageShift(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateShortageShift(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getTransportMode(isActive: boolean | undefined): Observable<TransportModeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetTransportMode?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportMode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportMode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransportModeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransportModeDto[]>;
        }));
    }

    protected processGetTransportMode(response: HttpResponseBase): Observable<TransportModeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TransportModeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateTransportMode(body: TransportModeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateTransportMode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateTransportMode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateTransportMode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateTransportMode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getStatusHotSheet(isActive: boolean | undefined): Observable<StatusHotSheetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetStatusHotSheet?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusHotSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusHotSheet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusHotSheetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusHotSheetDto[]>;
        }));
    }

    protected processGetStatusHotSheet(response: HttpResponseBase): Observable<StatusHotSheetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StatusHotSheetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateStatusHotSheet(body: StatusHotSheetDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateStatusHotSheet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateStatusHotSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateStatusHotSheet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateStatusHotSheet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCurrencies(): Observable<CurrencyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetCurrencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto[]>;
        }));
    }

    protected processGetCurrencies(response: HttpResponseBase): Observable<CurrencyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CurrencyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateCurrency(body: CurrencyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateCurrency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateCurrency(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param id (optional) 
     * @return Success
     */
    getDocumentTypes(isActive: boolean | undefined, id: number | undefined): Observable<DocumentTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetDocumentTypes?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentTypeDto[]>;
        }));
    }

    protected processGetDocumentTypes(response: HttpResponseBase): Observable<DocumentTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DocumentTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateDocumentType(body: DocumentTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateDocumentType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateDocumentType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateDocumentType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateDocumentType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPaymentTerms(id: number | undefined): Observable<PaymentTermDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPaymentTerms?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentTerms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentTerms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentTermDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentTermDto[]>;
        }));
    }

    protected processGetPaymentTerms(response: HttpResponseBase): Observable<PaymentTermDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentTermDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePaymentTerm(body: PaymentTermDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdatePaymentTerm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePaymentTerm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePaymentTerm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdatePaymentTerm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getBaseCatalogs(): Observable<BaseCatalogsDto> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetBaseCatalogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBaseCatalogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBaseCatalogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BaseCatalogsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BaseCatalogsDto>;
        }));
    }

    protected processGetBaseCatalogs(response: HttpResponseBase): Observable<BaseCatalogsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseCatalogsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isView (optional) 
     * @param hotSheetShiptId (optional) 
     * @return Success
     */
    getCatalogsForEdit(isView: boolean | undefined, hotSheetShiptId: number | undefined): Observable<CatalogsForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetCatalogsForEdit?";
        if (isView === null)
            throw new Error("The parameter 'isView' cannot be null.");
        else if (isView !== undefined)
            url_ += "IsView=" + encodeURIComponent("" + isView) + "&";
        if (hotSheetShiptId === null)
            throw new Error("The parameter 'hotSheetShiptId' cannot be null.");
        else if (hotSheetShiptId !== undefined)
            url_ += "HotSheetShiptId=" + encodeURIComponent("" + hotSheetShiptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCatalogsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCatalogsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogsForEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogsForEditDto>;
        }));
    }

    protected processGetCatalogsForEdit(response: HttpResponseBase): Observable<CatalogsForEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogsForEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDepartmentsByCurrentUser(): Observable<DepartmentByUserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetDepartmentsByCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentsByCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentsByCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentByUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentByUserDto[]>;
        }));
    }

    protected processGetDepartmentsByCurrentUser(response: HttpResponseBase): Observable<DepartmentByUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DepartmentByUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getDepartments(isActive: boolean | undefined): Observable<DepartmentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetDepartments?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentDto[]>;
        }));
    }

    protected processGetDepartments(response: HttpResponseBase): Observable<DepartmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DepartmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateDepartment(body: DepartmentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateDepartment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateDepartment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateDepartmentSp(body: DepartmentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateDepartmentSp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateDepartmentSp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateDepartmentSp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateDepartmentSp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param id (optional) 
     * @return Success
     */
    getServices(isActive: boolean | undefined, id: number | undefined): Observable<ServiceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetServices?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceDto[]>;
        }));
    }

    protected processGetServices(response: HttpResponseBase): Observable<ServiceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServiceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateService(body: ServiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateService";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateService(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPlantsByCurrentUser(): Observable<PlantByUserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPlantsByCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlantsByCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlantsByCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlantByUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlantByUserDto[]>;
        }));
    }

    protected processGetPlantsByCurrentUser(response: HttpResponseBase): Observable<PlantByUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PlantByUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getPlants(isActive: boolean | undefined): Observable<PlantDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPlants?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlantDto[]>;
        }));
    }

    protected processGetPlants(response: HttpResponseBase): Observable<PlantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PlantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePlant(body: PlantDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdatePlant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePlant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdatePlant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param id (optional) 
     * @return Success
     */
    getCarriers(isActive: boolean | undefined, id: number | undefined): Observable<CarrierDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetCarriers?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCarriers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCarriers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CarrierDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CarrierDto[]>;
        }));
    }

    protected processGetCarriers(response: HttpResponseBase): Observable<CarrierDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CarrierDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getCarrierServicesforEdit(): Observable<CurrentCarrierServicesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetCarrierServicesforEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCarrierServicesforEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCarrierServicesforEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentCarrierServicesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentCarrierServicesDto[]>;
        }));
    }

    protected processGetCarrierServicesforEdit(response: HttpResponseBase): Observable<CurrentCarrierServicesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CurrentCarrierServicesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateCarrier(body: CarrierDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateCarrier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateCarrier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateCarrier(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateCarrier(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param id (optional) 
     * @return Success
     */
    getHotSheetReasons(isActive: boolean | undefined, id: number | undefined): Observable<HotSheetReasonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetHotSheetReasons?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotSheetReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotSheetReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HotSheetReasonDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HotSheetReasonDto[]>;
        }));
    }

    protected processGetHotSheetReasons(response: HttpResponseBase): Observable<HotSheetReasonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HotSheetReasonDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateHotSheetReason(body: HotSheetReasonDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateHotSheetReason";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateHotSheetReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateHotSheetReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateHotSheetReason(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param id (optional) 
     * @return Success
     */
    getCustomers(isActive: boolean | undefined, id: number | undefined): Observable<CustomerDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetCustomers?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto[]>;
        }));
    }

    protected processGetCustomers(response: HttpResponseBase): Observable<CustomerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getActiveCustomers(): Observable<CustomerDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetActiveCustomers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveCustomers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto[]>;
        }));
    }

    protected processGetActiveCustomers(response: HttpResponseBase): Observable<CustomerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerById(customerId: number | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetCustomerById?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto>;
        }));
    }

    protected processGetCustomerById(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateCustomer(body: CustomerDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateCustomerPlant(body: CustomerPlantDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateCustomerPlant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateCustomerPlant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateCustomerPlant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateCustomerPlant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateCustomerPlantContact(body: CustomerPlantContactDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateCustomerPlantContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateCustomerPlantContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateCustomerPlantContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateCustomerPlantContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getHotSheetTerms(isActive: boolean | undefined): Observable<HotSheetTermDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetHotSheetTerms?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotSheetTerms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotSheetTerms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HotSheetTermDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HotSheetTermDto[]>;
        }));
    }

    protected processGetHotSheetTerms(response: HttpResponseBase): Observable<HotSheetTermDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HotSheetTermDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateHotSheetTerm(body: HotSheetTermDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateHotSheetTerm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateHotSheetTerm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateHotSheetTerm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateHotSheetTerm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getRmaAssignments(isActive: boolean | undefined): Observable<RmaAssignmentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetRmaAssignments?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRmaAssignments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRmaAssignments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RmaAssignmentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RmaAssignmentDto[]>;
        }));
    }

    protected processGetRmaAssignments(response: HttpResponseBase): Observable<RmaAssignmentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RmaAssignmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateRmaAssignment(body: RmaAssignmentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateRmaAssignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRmaAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRmaAssignment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateRmaAssignment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getPaidBy(isActive: boolean | undefined): Observable<PaidByDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPaidBy?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaidBy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaidBy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaidByDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaidByDto[]>;
        }));
    }

    protected processGetPaidBy(response: HttpResponseBase): Observable<PaidByDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaidByDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePaidBy(body: PaidByDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdatePaidBy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePaidBy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePaidBy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdatePaidBy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getUnitMeasures(isActive: boolean | undefined): Observable<UnitMeasureDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetUnitMeasures?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitMeasures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitMeasures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitMeasureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitMeasureDto[]>;
        }));
    }

    protected processGetUnitMeasures(response: HttpResponseBase): Observable<UnitMeasureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UnitMeasureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUnitMeasure(body: UnitMeasureDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateUnitMeasure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUnitMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUnitMeasure(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateUnitMeasure(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getStaff(isActive: boolean | undefined): Observable<StaffDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetStaff?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDto[]>;
        }));
    }

    protected processGetStaff(response: HttpResponseBase): Observable<StaffDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StaffDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getApproversStaff(): Observable<ApproverStaffDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetApproversStaff";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApproversStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApproversStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApproverStaffDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApproverStaffDto[]>;
        }));
    }

    protected processGetApproversStaff(response: HttpResponseBase): Observable<ApproverStaffDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ApproverStaffDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateStaff(body: StaffDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateStaff";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateStaff(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param productCodeSATIds (optional) 
     * @return Success
     */
    getProductCodesSat(isActive: boolean | undefined, productCodeSATIds: number[] | undefined): Observable<ProductCodeSATDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetProductCodesSat?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (productCodeSATIds === null)
            throw new Error("The parameter 'productCodeSATIds' cannot be null.");
        else if (productCodeSATIds !== undefined)
            productCodeSATIds && productCodeSATIds.forEach(item => { url_ += "productCodeSATIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCodesSat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCodesSat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductCodeSATDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductCodeSATDto[]>;
        }));
    }

    protected processGetProductCodesSat(response: HttpResponseBase): Observable<ProductCodeSATDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductCodeSATDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateProductCodeSat(body: ProductCodeSATDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateProductCodeSat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateProductCodeSat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateProductCodeSat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateProductCodeSat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param hotSheetShiptId (optional) 
     * @return Success
     */
    getPartNumbersForSelect(hotSheetShiptId: number | undefined): Observable<PartNumberForSelectDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPartNumbersForSelect?";
        if (hotSheetShiptId === null)
            throw new Error("The parameter 'hotSheetShiptId' cannot be null.");
        else if (hotSheetShiptId !== undefined)
            url_ += "HotSheetShiptId=" + encodeURIComponent("" + hotSheetShiptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartNumbersForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartNumbersForSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartNumberForSelectDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartNumberForSelectDto[]>;
        }));
    }

    protected processGetPartNumbersForSelect(response: HttpResponseBase): Observable<PartNumberForSelectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PartNumberForSelectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getPartNumbers(isActive: boolean | undefined): Observable<PartNumberDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPartNumbers?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartNumbers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartNumbers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartNumberDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartNumberDto[]>;
        }));
    }

    protected processGetPartNumbers(response: HttpResponseBase): Observable<PartNumberDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PartNumberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getPartNumbersInternal(isActive: boolean | undefined): Observable<PartNumberInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPartNumbersInternal?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartNumbersInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartNumbersInternal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartNumberInternalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartNumberInternalDto[]>;
        }));
    }

    protected processGetPartNumbersInternal(response: HttpResponseBase): Observable<PartNumberInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PartNumberInternalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePartNumber(body: PartNumberDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdatePartNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePartNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePartNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdatePartNumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePartNumberInternal(body: PartNumberInternalDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdatePartNumberInternal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePartNumberInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePartNumberInternal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdatePartNumberInternal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePartNumberXLSX(body: PartNumberXlsxDto[] | undefined): Observable<PartNumberResXlsxDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdatePartNumberXLSX";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePartNumberXLSX(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePartNumberXLSX(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartNumberResXlsxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartNumberResXlsxDto[]>;
        }));
    }

    protected processCreateOrUpdatePartNumberXLSX(response: HttpResponseBase): Observable<PartNumberResXlsxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PartNumberResXlsxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePartNumberInternalXLSX(body: PartNumberInternalXlsxDto[] | undefined): Observable<PartNumberInternalResXlsxDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdatePartNumberInternalXLSX";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePartNumberInternalXLSX(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePartNumberInternalXLSX(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartNumberInternalResXlsxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartNumberInternalResXlsxDto[]>;
        }));
    }

    protected processCreateOrUpdatePartNumberInternalXLSX(response: HttpResponseBase): Observable<PartNumberInternalResXlsxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PartNumberInternalResXlsxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param id (optional) 
     * @return Success
     */
    getSpecialExpeditedReason(isActive: boolean | undefined, id: number | undefined): Observable<SpecialExpeditedReasonDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetSpecialExpeditedReason?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpecialExpeditedReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpecialExpeditedReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpecialExpeditedReasonDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpecialExpeditedReasonDto[]>;
        }));
    }

    protected processGetSpecialExpeditedReason(response: HttpResponseBase): Observable<SpecialExpeditedReasonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SpecialExpeditedReasonDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getPackaging(isActive: boolean | undefined): Observable<PackagingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPackaging?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PackagingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PackagingDto[]>;
        }));
    }

    protected processGetPackaging(response: HttpResponseBase): Observable<PackagingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PackagingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getStatus(): Observable<DocumentStatusDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentStatusDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentStatusDto[]>;
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<DocumentStatusDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DocumentStatusDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getPartNumberPrices(isActive: boolean | undefined): Observable<PartNumberPriceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPartNumberPrices?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartNumberPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartNumberPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartNumberPriceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartNumberPriceDto[]>;
        }));
    }

    protected processGetPartNumberPrices(response: HttpResponseBase): Observable<PartNumberPriceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PartNumberPriceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getPartNumberPricesInternal(isActive: boolean | undefined): Observable<PartNumberPriceInternalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPartNumberPricesInternal?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartNumberPricesInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartNumberPricesInternal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartNumberPriceInternalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartNumberPriceInternalDto[]>;
        }));
    }

    protected processGetPartNumberPricesInternal(response: HttpResponseBase): Observable<PartNumberPriceInternalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PartNumberPriceInternalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePartNumberPrice(body: PartNumberPriceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdatePartNumberPrice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePartNumberPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePartNumberPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdatePartNumberPrice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePartNumberPriceInternal(body: PartNumberPriceInternalDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdatePartNumberPriceInternal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePartNumberPriceInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePartNumberPriceInternal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdatePartNumberPriceInternal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getHelpInfo(): Observable<HelpInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetHelpInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHelpInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHelpInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HelpInfoDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HelpInfoDto[]>;
        }));
    }

    protected processGetHelpInfo(response: HttpResponseBase): Observable<HelpInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HelpInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getHelpInfoFields(): Observable<HelpInfoFieldDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetHelpInfoFields";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHelpInfoFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHelpInfoFields(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HelpInfoFieldDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HelpInfoFieldDto[]>;
        }));
    }

    protected processGetHelpInfoFields(response: HttpResponseBase): Observable<HelpInfoFieldDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HelpInfoFieldDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateHelpInfo(body: HelpInfoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateHelpInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateHelpInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateHelpInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateHelpInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEmployees(): Observable<EmployeeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetEmployees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDto[]>;
        }));
    }

    protected processGetEmployees(response: HttpResponseBase): Observable<EmployeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EmployeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEmployeesList(): Observable<EmployeeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetEmployeesList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDto[]>;
        }));
    }

    protected processGetEmployeesList(response: HttpResponseBase): Observable<EmployeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EmployeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEmployeeOptions(): Observable<EmployeeOptionsDto> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetEmployeeOptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeOptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeOptionsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeOptionsDto>;
        }));
    }

    protected processGetEmployeeOptions(response: HttpResponseBase): Observable<EmployeeOptionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeOptionsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEmployeeTypes(): Observable<EmployeeType[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetEmployeeTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeType[]>;
        }));
    }

    protected processGetEmployeeTypes(response: HttpResponseBase): Observable<EmployeeType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EmployeeType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEmployeeLevels(): Observable<EmployeeLevel[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetEmployeeLevels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeLevels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeLevel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeLevel[]>;
        }));
    }

    protected processGetEmployeeLevels(response: HttpResponseBase): Observable<EmployeeLevel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EmployeeLevel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEmployeePositions(): Observable<EmployeePosition[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetEmployeePositions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeePositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeePositions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeePosition[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeePosition[]>;
        }));
    }

    protected processGetEmployeePositions(response: HttpResponseBase): Observable<EmployeePosition[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EmployeePosition.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateEmployee(body: EmployeeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateEmployee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateEmployee(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getNotices(): Observable<NoticeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetNotices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeDto[]>;
        }));
    }

    protected processGetNotices(response: HttpResponseBase): Observable<NoticeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NoticeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getNoticesToDisplay(): Observable<NoticeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetNoticesToDisplay";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoticesToDisplay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoticesToDisplay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoticeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoticeDto[]>;
        }));
    }

    protected processGetNoticesToDisplay(response: HttpResponseBase): Observable<NoticeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NoticeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateNotice(body: NoticeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/CreateOrUpdateNotice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateNotice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateNotice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateNotice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPaymentStatus(): Observable<PaymentStatus[]> {
        let url_ = this.baseUrl + "/api/services/app/Catalog/GetPaymentStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentStatus[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentStatus[]>;
        }));
    }

    protected processGetPaymentStatus(response: HttpResponseBase): Observable<PaymentStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getSettings(): Observable<SettingsParametersDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingsParametersDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingsParametersDto[]>;
        }));
    }

    protected processGetSettings(response: HttpResponseBase): Observable<SettingsParametersDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SettingsParametersDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateSetting(body: SettingsParametersDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/CreateOrUpdateSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param entityType (optional) 
     * @param entityId (optional) 
     * @param file (optional) 
     * @return Success
     */
    upload(entityType: string | undefined, entityId: number | undefined, file: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/File/Upload?";
        if (entityType === null)
            throw new Error("The parameter 'entityType' cannot be null.");
        else if (entityType !== undefined)
            url_ += "entityType=" + encodeURIComponent("" + entityType) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HotSheetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getHotSheets(body: GetHotSheetInput | undefined): Observable<HotSheetsItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/GetHotSheets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotSheets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotSheets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HotSheetsItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HotSheetsItemDto[]>;
        }));
    }

    protected processGetHotSheets(response: HttpResponseBase): Observable<HotSheetsItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HotSheetsItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPurchaseOrders(body: GetPurchaseOrdersInput | undefined): Observable<PurchaseOrdersItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/GetPurchaseOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseOrdersItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseOrdersItemDto[]>;
        }));
    }

    protected processGetPurchaseOrders(response: HttpResponseBase): Observable<PurchaseOrdersItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PurchaseOrdersItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getStarSheets(body: GetStarSheetInput | undefined): Observable<StarSheetsItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/GetStarSheets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStarSheets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStarSheets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StarSheetsItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StarSheetsItemDto[]>;
        }));
    }

    protected processGetStarSheets(response: HttpResponseBase): Observable<StarSheetsItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StarSheetsItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param hotSheetId (optional) 
     * @return Success
     */
    getHotSheetById(hotSheetId: number | undefined): Observable<HotSheetsItemDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/GetHotSheetById?";
        if (hotSheetId === null)
            throw new Error("The parameter 'hotSheetId' cannot be null.");
        else if (hotSheetId !== undefined)
            url_ += "HotSheetId=" + encodeURIComponent("" + hotSheetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotSheetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotSheetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HotSheetsItemDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HotSheetsItemDetailDto>;
        }));
    }

    protected processGetHotSheetById(response: HttpResponseBase): Observable<HotSheetsItemDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HotSheetsItemDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param purchaseOrderId (optional) 
     * @return Success
     */
    getPurchaseOrderById(purchaseOrderId: number | undefined): Observable<PurchaseOrdersItemDto> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/GetPurchaseOrderById?";
        if (purchaseOrderId === null)
            throw new Error("The parameter 'purchaseOrderId' cannot be null.");
        else if (purchaseOrderId !== undefined)
            url_ += "PurchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseOrderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseOrderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseOrdersItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseOrdersItemDto>;
        }));
    }

    protected processGetPurchaseOrderById(response: HttpResponseBase): Observable<PurchaseOrdersItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseOrdersItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param starSheetId (optional) 
     * @return Success
     */
    getStarSheetById(starSheetId: number | undefined): Observable<StarSheetsItemDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/GetStarSheetById?";
        if (starSheetId === null)
            throw new Error("The parameter 'starSheetId' cannot be null.");
        else if (starSheetId !== undefined)
            url_ += "StarSheetId=" + encodeURIComponent("" + starSheetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStarSheetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStarSheetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StarSheetsItemDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StarSheetsItemDetailDto>;
        }));
    }

    protected processGetStarSheetById(response: HttpResponseBase): Observable<StarSheetsItemDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StarSheetsItemDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param hotSheetId (optional) 
     * @return Success
     */
    getHotSheetFiles(hotSheetId: number | undefined): Observable<FileDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/GetHotSheetFiles?";
        if (hotSheetId === null)
            throw new Error("The parameter 'hotSheetId' cannot be null.");
        else if (hotSheetId !== undefined)
            url_ += "HotSheetId=" + encodeURIComponent("" + hotSheetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotSheetFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotSheetFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto[]>;
        }));
    }

    protected processGetHotSheetFiles(response: HttpResponseBase): Observable<FileDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FileDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param starSheetId (optional) 
     * @return Success
     */
    getStarSheetFiles(starSheetId: number | undefined): Observable<FileDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/GetStarSheetFiles?";
        if (starSheetId === null)
            throw new Error("The parameter 'starSheetId' cannot be null.");
        else if (starSheetId !== undefined)
            url_ += "StarSheetId=" + encodeURIComponent("" + starSheetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStarSheetFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStarSheetFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto[]>;
        }));
    }

    protected processGetStarSheetFiles(response: HttpResponseBase): Observable<FileDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FileDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStartSheetToHotSheet(body: StarSheetsItemDto[] | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/UpdateStartSheetToHotSheet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStartSheetToHotSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStartSheetToHotSheet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateStartSheetToHotSheet(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateHotSheet(body: HotSheetsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/CreateOrUpdateHotSheet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateHotSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateHotSheet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateHotSheet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePurchaseOrder(body: PurchaseOrdersDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/CreateOrUpdatePurchaseOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePurchaseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePurchaseOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdatePurchaseOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param purchaseOrderId (optional) 
     * @return Success
     */
    deletePurchaseOrder(purchaseOrderId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/DeletePurchaseOrder?";
        if (purchaseOrderId === null)
            throw new Error("The parameter 'purchaseOrderId' cannot be null.");
        else if (purchaseOrderId !== undefined)
            url_ += "purchaseOrderId=" + encodeURIComponent("" + purchaseOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePurchaseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePurchaseOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePurchaseOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateStarSheet(body: StarSheetsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/CreateOrUpdateStarSheet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateStarSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateStarSheet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateStarSheet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param hotSheetId (optional) 
     * @return Success
     */
    getHotSheetComments(hotSheetId: number | undefined): Observable<HotSheetsCommetsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/GetHotSheetComments?";
        if (hotSheetId === null)
            throw new Error("The parameter 'hotSheetId' cannot be null.");
        else if (hotSheetId !== undefined)
            url_ += "HotSheetId=" + encodeURIComponent("" + hotSheetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotSheetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotSheetComments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HotSheetsCommetsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HotSheetsCommetsDto[]>;
        }));
    }

    protected processGetHotSheetComments(response: HttpResponseBase): Observable<HotSheetsCommetsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HotSheetsCommetsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param hotSheetId (optional) 
     * @return Success
     */
    getStarSheetComments(hotSheetId: number | undefined): Observable<StarSheetsCommetsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/GetStarSheetComments?";
        if (hotSheetId === null)
            throw new Error("The parameter 'hotSheetId' cannot be null.");
        else if (hotSheetId !== undefined)
            url_ += "HotSheetId=" + encodeURIComponent("" + hotSheetId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStarSheetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStarSheetComments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StarSheetsCommetsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StarSheetsCommetsDto[]>;
        }));
    }

    protected processGetStarSheetComments(response: HttpResponseBase): Observable<StarSheetsCommetsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StarSheetsCommetsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateHotSheetComments(body: HotSheetsCommetsDto | undefined): Observable<HotSheetsCommetsDto> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/CreateOrUpdateHotSheetComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateHotSheetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateHotSheetComments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HotSheetsCommetsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HotSheetsCommetsDto>;
        }));
    }

    protected processCreateOrUpdateHotSheetComments(response: HttpResponseBase): Observable<HotSheetsCommetsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HotSheetsCommetsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateStarSheetComments(body: StarSheetsCommetsDto | undefined): Observable<StarSheetsCommetsDto> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/CreateOrUpdateStarSheetComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateStarSheetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateStarSheetComments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StarSheetsCommetsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StarSheetsCommetsDto>;
        }));
    }

    protected processCreateOrUpdateStarSheetComments(response: HttpResponseBase): Observable<StarSheetsCommetsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StarSheetsCommetsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fileId (optional) 
     * @return Success
     */
    deleteFile(fileId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HotSheet/DeleteFile?";
        if (fileId === null)
            throw new Error("The parameter 'fileId' cannot be null.");
        else if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InterfaceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUsersFromEmployees(body: CreateUsersFromEmployeesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Interface/CreateUsersFromEmployees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsersFromEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsersFromEmployees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateUsersFromEmployees(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendReminders(body: SendRemindersInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Interface/SendReminders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendReminders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendReminders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendReminders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    aS400Test(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Interface/AS400Test";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAS400Test(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAS400Test(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAS400Test(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param hotSheetShiptId (optional) 
     * @return Success
     */
    sendSurveyRequest(hotSheetShiptId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Interface/SendSurveyRequest?";
        if (hotSheetShiptId === null)
            throw new Error("The parameter 'hotSheetShiptId' cannot be null.");
        else if (hotSheetShiptId !== undefined)
            url_ += "HotSheetShiptId=" + encodeURIComponent("" + hotSheetShiptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendSurveyRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendSurveyRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendSurveyRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SurveyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param shippingCode (optional) 
     * @param creationDate (optional) 
     * @param qualification (optional) 
     * @return Success
     */
    getSurveys(userId: number | undefined, shippingCode: string | undefined, creationDate: moment.Moment | undefined, qualification: string | undefined): Observable<SurveyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Survey/GetSurveys?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (shippingCode === null)
            throw new Error("The parameter 'shippingCode' cannot be null.");
        else if (shippingCode !== undefined)
            url_ += "ShippingCode=" + encodeURIComponent("" + shippingCode) + "&";
        if (creationDate === null)
            throw new Error("The parameter 'creationDate' cannot be null.");
        else if (creationDate !== undefined)
            url_ += "CreationDate=" + encodeURIComponent(creationDate ? "" + creationDate.toISOString() : "") + "&";
        if (qualification === null)
            throw new Error("The parameter 'qualification' cannot be null.");
        else if (qualification !== undefined)
            url_ += "Qualification=" + encodeURIComponent("" + qualification) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveys(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SurveyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SurveyDto[]>;
        }));
    }

    protected processGetSurveys(response: HttpResponseBase): Observable<SurveyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SurveyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveSurvey(body: SurveyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Survey/SaveSurvey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSurvey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSurvey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveSurvey(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDensoAs400Settings(body: DensoAS400SettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateDensoAs400Settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDensoAs400Settings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDensoAs400Settings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDensoAs400Settings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDensoInterfacesSettings(body: DensoInterfacesSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateDensoInterfacesSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDensoInterfacesSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDensoInterfacesSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDensoInterfacesSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDensoGeneralSettings(body: DensoGeneralSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateDensoGeneralSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDensoGeneralSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDensoGeneralSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDensoGeneralSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param emailAddress (optional) 
     * @return Success
     */
    testEmail(emailAddress: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/TestEmail?";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserName(): Observable<string> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetUserName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetUserName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param email (optional) 
     * @param password (optional) 
     * @return Success
     */
    authenticateLdap(email: string | undefined, password: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateLdap?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateLdap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateLdap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAuthenticateLdap(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getUsersByCurrentUser(): Observable<UserByCurrentUserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersByCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersByCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersByCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserByCurrentUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserByCurrentUserDto[]>;
        }));
    }

    protected processGetUsersByCurrentUser(response: HttpResponseBase): Observable<UserByCurrentUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserByCurrentUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class ApproverStaffDto implements IApproverStaffDto {
    userId: number;
    fullName: string | undefined;
    approverName: string | undefined;
    densoFullName: string | undefined;
    departmentId: number;
    departmentName: string | undefined;
    staffId: number;
    type: number;
    plantId: number;
    plantName: string | undefined;

    constructor(data?: IApproverStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.fullName = _data["fullName"];
            this.approverName = _data["approverName"];
            this.densoFullName = _data["densoFullName"];
            this.departmentId = _data["departmentId"];
            this.departmentName = _data["departmentName"];
            this.staffId = _data["staffId"];
            this.type = _data["type"];
            this.plantId = _data["plantId"];
            this.plantName = _data["plantName"];
        }
    }

    static fromJS(data: any): ApproverStaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApproverStaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["fullName"] = this.fullName;
        data["approverName"] = this.approverName;
        data["densoFullName"] = this.densoFullName;
        data["departmentId"] = this.departmentId;
        data["departmentName"] = this.departmentName;
        data["staffId"] = this.staffId;
        data["type"] = this.type;
        data["plantId"] = this.plantId;
        data["plantName"] = this.plantName;
        return data;
    }

    clone(): ApproverStaffDto {
        const json = this.toJSON();
        let result = new ApproverStaffDto();
        result.init(json);
        return result;
    }
}

export interface IApproverStaffDto {
    userId: number;
    fullName: string | undefined;
    approverName: string | undefined;
    densoFullName: string | undefined;
    departmentId: number;
    departmentName: string | undefined;
    staffId: number;
    type: number;
    plantId: number;
    plantName: string | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class BaseCatalogsDto implements IBaseCatalogsDto {
    carriers: CarrierDto[] | undefined;
    documentTypes: DocumentTypeDto[] | undefined;
    paymentTerms: PaymentTermDto[] | undefined;
    hotSheetReasons: HotSheetReasonDto[] | undefined;
    services: ServiceDto[] | undefined;
    status: DocumentStatusDto[] | undefined;

    constructor(data?: IBaseCatalogsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["carriers"])) {
                this.carriers = [] as any;
                for (let item of _data["carriers"])
                    this.carriers.push(CarrierDto.fromJS(item));
            }
            if (Array.isArray(_data["documentTypes"])) {
                this.documentTypes = [] as any;
                for (let item of _data["documentTypes"])
                    this.documentTypes.push(DocumentTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["paymentTerms"])) {
                this.paymentTerms = [] as any;
                for (let item of _data["paymentTerms"])
                    this.paymentTerms.push(PaymentTermDto.fromJS(item));
            }
            if (Array.isArray(_data["hotSheetReasons"])) {
                this.hotSheetReasons = [] as any;
                for (let item of _data["hotSheetReasons"])
                    this.hotSheetReasons.push(HotSheetReasonDto.fromJS(item));
            }
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services.push(ServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["status"])) {
                this.status = [] as any;
                for (let item of _data["status"])
                    this.status.push(DocumentStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseCatalogsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaseCatalogsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.carriers)) {
            data["carriers"] = [];
            for (let item of this.carriers)
                data["carriers"].push(item.toJSON());
        }
        if (Array.isArray(this.documentTypes)) {
            data["documentTypes"] = [];
            for (let item of this.documentTypes)
                data["documentTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentTerms)) {
            data["paymentTerms"] = [];
            for (let item of this.paymentTerms)
                data["paymentTerms"].push(item.toJSON());
        }
        if (Array.isArray(this.hotSheetReasons)) {
            data["hotSheetReasons"] = [];
            for (let item of this.hotSheetReasons)
                data["hotSheetReasons"].push(item.toJSON());
        }
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        if (Array.isArray(this.status)) {
            data["status"] = [];
            for (let item of this.status)
                data["status"].push(item.toJSON());
        }
        return data;
    }

    clone(): BaseCatalogsDto {
        const json = this.toJSON();
        let result = new BaseCatalogsDto();
        result.init(json);
        return result;
    }
}

export interface IBaseCatalogsDto {
    carriers: CarrierDto[] | undefined;
    documentTypes: DocumentTypeDto[] | undefined;
    paymentTerms: PaymentTermDto[] | undefined;
    hotSheetReasons: HotSheetReasonDto[] | undefined;
    services: ServiceDto[] | undefined;
    status: DocumentStatusDto[] | undefined;
}

export class BaseDepartmentDto implements IBaseDepartmentDto {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IBaseDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BaseDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): BaseDepartmentDto {
        const json = this.toJSON();
        let result = new BaseDepartmentDto();
        result.init(json);
        return result;
    }
}

export interface IBaseDepartmentDto {
    id: number | undefined;
    name: string | undefined;
}

export class BasePlantDto implements IBasePlantDto {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IBasePlantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BasePlantDto {
        data = typeof data === 'object' ? data : {};
        let result = new BasePlantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): BasePlantDto {
        const json = this.toJSON();
        let result = new BasePlantDto();
        result.init(json);
        return result;
    }
}

export interface IBasePlantDto {
    id: number | undefined;
    name: string | undefined;
}

export class CarrierDto implements ICarrierDto {
    id: number | undefined;
    name: string | undefined;
    documentTypeId: number;
    documentType: DocumentTypeDto;
    divisorNumber: number | undefined;
    isActive: boolean;
    services: CarrierServiceDto[] | undefined;
    fullName: string | undefined;
    nonWorkingDays: CarrierNonWorkingDayDto[] | undefined;

    constructor(data?: ICarrierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentType = _data["documentType"] ? DocumentTypeDto.fromJS(_data["documentType"]) : <any>undefined;
            this.divisorNumber = _data["divisorNumber"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services.push(CarrierServiceDto.fromJS(item));
            }
            this.fullName = _data["fullName"];
            if (Array.isArray(_data["nonWorkingDays"])) {
                this.nonWorkingDays = [] as any;
                for (let item of _data["nonWorkingDays"])
                    this.nonWorkingDays.push(CarrierNonWorkingDayDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CarrierDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarrierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["documentTypeId"] = this.documentTypeId;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["divisorNumber"] = this.divisorNumber;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        data["fullName"] = this.fullName;
        if (Array.isArray(this.nonWorkingDays)) {
            data["nonWorkingDays"] = [];
            for (let item of this.nonWorkingDays)
                data["nonWorkingDays"].push(item.toJSON());
        }
        return data;
    }

    clone(): CarrierDto {
        const json = this.toJSON();
        let result = new CarrierDto();
        result.init(json);
        return result;
    }
}

export interface ICarrierDto {
    id: number | undefined;
    name: string | undefined;
    documentTypeId: number;
    documentType: DocumentTypeDto;
    divisorNumber: number | undefined;
    isActive: boolean;
    services: CarrierServiceDto[] | undefined;
    fullName: string | undefined;
    nonWorkingDays: CarrierNonWorkingDayDto[] | undefined;
}

export class CarrierNonWorkingDayDto implements ICarrierNonWorkingDayDto {
    id: number | undefined;
    carrierId: number;
    carrierName: string | undefined;
    nonWorkingDay: moment.Moment;
    isActive: boolean;

    constructor(data?: ICarrierNonWorkingDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.carrierId = _data["carrierId"];
            this.carrierName = _data["carrierName"];
            this.nonWorkingDay = _data["nonWorkingDay"] ? moment(_data["nonWorkingDay"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CarrierNonWorkingDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarrierNonWorkingDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["carrierId"] = this.carrierId;
        data["carrierName"] = this.carrierName;
        data["nonWorkingDay"] = this.nonWorkingDay ? this.nonWorkingDay.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CarrierNonWorkingDayDto {
        const json = this.toJSON();
        let result = new CarrierNonWorkingDayDto();
        result.init(json);
        return result;
    }
}

export interface ICarrierNonWorkingDayDto {
    id: number | undefined;
    carrierId: number;
    carrierName: string | undefined;
    nonWorkingDay: moment.Moment;
    isActive: boolean;
}

export class CarrierServiceDto implements ICarrierServiceDto {
    id: number | undefined;
    carrierId: number;
    serviceId: number;
    service: ServiceDto;

    constructor(data?: ICarrierServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.carrierId = _data["carrierId"];
            this.serviceId = _data["serviceId"];
            this.service = _data["service"] ? ServiceDto.fromJS(_data["service"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CarrierServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarrierServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["carrierId"] = this.carrierId;
        data["serviceId"] = this.serviceId;
        data["service"] = this.service ? this.service.toJSON() : <any>undefined;
        return data;
    }

    clone(): CarrierServiceDto {
        const json = this.toJSON();
        let result = new CarrierServiceDto();
        result.init(json);
        return result;
    }
}

export interface ICarrierServiceDto {
    id: number | undefined;
    carrierId: number;
    serviceId: number;
    service: ServiceDto;
}

export class CatalogsForEditDto implements ICatalogsForEditDto {
    carriers: CarrierDto[] | undefined;
    documentTypes: DocumentTypeDto[] | undefined;
    paymentTerms: PaymentTermDto[] | undefined;
    hotSheetReasons: HotSheetReasonDto[] | undefined;
    services: ServiceDto[] | undefined;
    status: DocumentStatusDto[] | undefined;
    customers: CustomerDto[] | undefined;
    departmentsByUser: DepartmentByUserDto[] | undefined;
    plantsByUser: PlantByUserDto[] | undefined;
    hotSheetTerms: HotSheetTermDto[] | undefined;
    rmaAssignments: RmaAssignmentDto[] | undefined;
    paidBy: PaidByDto[] | undefined;
    specialExpeditedReasons: SpecialExpeditedReasonDto[] | undefined;
    approversStaff: ApproverStaffDto[] | undefined;
    helpInfo: HelpInfoDto[] | undefined;
    partNumbers: PartNumberForSelectDto[] | undefined;
    unitMeasures: UnitMeasureDto[] | undefined;
    productCodesSAT: ProductCodeSATDto[] | undefined;
    countries: CountryDto[] | undefined;
    currencies: CurrencyDto[] | undefined;

    constructor(data?: ICatalogsForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["carriers"])) {
                this.carriers = [] as any;
                for (let item of _data["carriers"])
                    this.carriers.push(CarrierDto.fromJS(item));
            }
            if (Array.isArray(_data["documentTypes"])) {
                this.documentTypes = [] as any;
                for (let item of _data["documentTypes"])
                    this.documentTypes.push(DocumentTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["paymentTerms"])) {
                this.paymentTerms = [] as any;
                for (let item of _data["paymentTerms"])
                    this.paymentTerms.push(PaymentTermDto.fromJS(item));
            }
            if (Array.isArray(_data["hotSheetReasons"])) {
                this.hotSheetReasons = [] as any;
                for (let item of _data["hotSheetReasons"])
                    this.hotSheetReasons.push(HotSheetReasonDto.fromJS(item));
            }
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services.push(ServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["status"])) {
                this.status = [] as any;
                for (let item of _data["status"])
                    this.status.push(DocumentStatusDto.fromJS(item));
            }
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers.push(CustomerDto.fromJS(item));
            }
            if (Array.isArray(_data["departmentsByUser"])) {
                this.departmentsByUser = [] as any;
                for (let item of _data["departmentsByUser"])
                    this.departmentsByUser.push(DepartmentByUserDto.fromJS(item));
            }
            if (Array.isArray(_data["plantsByUser"])) {
                this.plantsByUser = [] as any;
                for (let item of _data["plantsByUser"])
                    this.plantsByUser.push(PlantByUserDto.fromJS(item));
            }
            if (Array.isArray(_data["hotSheetTerms"])) {
                this.hotSheetTerms = [] as any;
                for (let item of _data["hotSheetTerms"])
                    this.hotSheetTerms.push(HotSheetTermDto.fromJS(item));
            }
            if (Array.isArray(_data["rmaAssignments"])) {
                this.rmaAssignments = [] as any;
                for (let item of _data["rmaAssignments"])
                    this.rmaAssignments.push(RmaAssignmentDto.fromJS(item));
            }
            if (Array.isArray(_data["paidBy"])) {
                this.paidBy = [] as any;
                for (let item of _data["paidBy"])
                    this.paidBy.push(PaidByDto.fromJS(item));
            }
            if (Array.isArray(_data["specialExpeditedReasons"])) {
                this.specialExpeditedReasons = [] as any;
                for (let item of _data["specialExpeditedReasons"])
                    this.specialExpeditedReasons.push(SpecialExpeditedReasonDto.fromJS(item));
            }
            if (Array.isArray(_data["approversStaff"])) {
                this.approversStaff = [] as any;
                for (let item of _data["approversStaff"])
                    this.approversStaff.push(ApproverStaffDto.fromJS(item));
            }
            if (Array.isArray(_data["helpInfo"])) {
                this.helpInfo = [] as any;
                for (let item of _data["helpInfo"])
                    this.helpInfo.push(HelpInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["partNumbers"])) {
                this.partNumbers = [] as any;
                for (let item of _data["partNumbers"])
                    this.partNumbers.push(PartNumberForSelectDto.fromJS(item));
            }
            if (Array.isArray(_data["unitMeasures"])) {
                this.unitMeasures = [] as any;
                for (let item of _data["unitMeasures"])
                    this.unitMeasures.push(UnitMeasureDto.fromJS(item));
            }
            if (Array.isArray(_data["productCodesSAT"])) {
                this.productCodesSAT = [] as any;
                for (let item of _data["productCodesSAT"])
                    this.productCodesSAT.push(ProductCodeSATDto.fromJS(item));
            }
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries.push(CountryDto.fromJS(item));
            }
            if (Array.isArray(_data["currencies"])) {
                this.currencies = [] as any;
                for (let item of _data["currencies"])
                    this.currencies.push(CurrencyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CatalogsForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogsForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.carriers)) {
            data["carriers"] = [];
            for (let item of this.carriers)
                data["carriers"].push(item.toJSON());
        }
        if (Array.isArray(this.documentTypes)) {
            data["documentTypes"] = [];
            for (let item of this.documentTypes)
                data["documentTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentTerms)) {
            data["paymentTerms"] = [];
            for (let item of this.paymentTerms)
                data["paymentTerms"].push(item.toJSON());
        }
        if (Array.isArray(this.hotSheetReasons)) {
            data["hotSheetReasons"] = [];
            for (let item of this.hotSheetReasons)
                data["hotSheetReasons"].push(item.toJSON());
        }
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        if (Array.isArray(this.status)) {
            data["status"] = [];
            for (let item of this.status)
                data["status"].push(item.toJSON());
        }
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        if (Array.isArray(this.departmentsByUser)) {
            data["departmentsByUser"] = [];
            for (let item of this.departmentsByUser)
                data["departmentsByUser"].push(item.toJSON());
        }
        if (Array.isArray(this.plantsByUser)) {
            data["plantsByUser"] = [];
            for (let item of this.plantsByUser)
                data["plantsByUser"].push(item.toJSON());
        }
        if (Array.isArray(this.hotSheetTerms)) {
            data["hotSheetTerms"] = [];
            for (let item of this.hotSheetTerms)
                data["hotSheetTerms"].push(item.toJSON());
        }
        if (Array.isArray(this.rmaAssignments)) {
            data["rmaAssignments"] = [];
            for (let item of this.rmaAssignments)
                data["rmaAssignments"].push(item.toJSON());
        }
        if (Array.isArray(this.paidBy)) {
            data["paidBy"] = [];
            for (let item of this.paidBy)
                data["paidBy"].push(item.toJSON());
        }
        if (Array.isArray(this.specialExpeditedReasons)) {
            data["specialExpeditedReasons"] = [];
            for (let item of this.specialExpeditedReasons)
                data["specialExpeditedReasons"].push(item.toJSON());
        }
        if (Array.isArray(this.approversStaff)) {
            data["approversStaff"] = [];
            for (let item of this.approversStaff)
                data["approversStaff"].push(item.toJSON());
        }
        if (Array.isArray(this.helpInfo)) {
            data["helpInfo"] = [];
            for (let item of this.helpInfo)
                data["helpInfo"].push(item.toJSON());
        }
        if (Array.isArray(this.partNumbers)) {
            data["partNumbers"] = [];
            for (let item of this.partNumbers)
                data["partNumbers"].push(item.toJSON());
        }
        if (Array.isArray(this.unitMeasures)) {
            data["unitMeasures"] = [];
            for (let item of this.unitMeasures)
                data["unitMeasures"].push(item.toJSON());
        }
        if (Array.isArray(this.productCodesSAT)) {
            data["productCodesSAT"] = [];
            for (let item of this.productCodesSAT)
                data["productCodesSAT"].push(item.toJSON());
        }
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        if (Array.isArray(this.currencies)) {
            data["currencies"] = [];
            for (let item of this.currencies)
                data["currencies"].push(item.toJSON());
        }
        return data;
    }

    clone(): CatalogsForEditDto {
        const json = this.toJSON();
        let result = new CatalogsForEditDto();
        result.init(json);
        return result;
    }
}

export interface ICatalogsForEditDto {
    carriers: CarrierDto[] | undefined;
    documentTypes: DocumentTypeDto[] | undefined;
    paymentTerms: PaymentTermDto[] | undefined;
    hotSheetReasons: HotSheetReasonDto[] | undefined;
    services: ServiceDto[] | undefined;
    status: DocumentStatusDto[] | undefined;
    customers: CustomerDto[] | undefined;
    departmentsByUser: DepartmentByUserDto[] | undefined;
    plantsByUser: PlantByUserDto[] | undefined;
    hotSheetTerms: HotSheetTermDto[] | undefined;
    rmaAssignments: RmaAssignmentDto[] | undefined;
    paidBy: PaidByDto[] | undefined;
    specialExpeditedReasons: SpecialExpeditedReasonDto[] | undefined;
    approversStaff: ApproverStaffDto[] | undefined;
    helpInfo: HelpInfoDto[] | undefined;
    partNumbers: PartNumberForSelectDto[] | undefined;
    unitMeasures: UnitMeasureDto[] | undefined;
    productCodesSAT: ProductCodeSATDto[] | undefined;
    countries: CountryDto[] | undefined;
    currencies: CurrencyDto[] | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class CountryDto implements ICountryDto {
    id: number | undefined;
    name: string | undefined;
    nameSpanish: string | undefined;
    densoCode: string | undefined;
    satCode: string | undefined;
    segroveCode: string | undefined;
    fullName: string | undefined;
    isActive: boolean;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nameSpanish = _data["nameSpanish"];
            this.densoCode = _data["densoCode"];
            this.satCode = _data["satCode"];
            this.segroveCode = _data["segroveCode"];
            this.fullName = _data["fullName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nameSpanish"] = this.nameSpanish;
        data["densoCode"] = this.densoCode;
        data["satCode"] = this.satCode;
        data["segroveCode"] = this.segroveCode;
        data["fullName"] = this.fullName;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CountryDto {
        const json = this.toJSON();
        let result = new CountryDto();
        result.init(json);
        return result;
    }
}

export interface ICountryDto {
    id: number | undefined;
    name: string | undefined;
    nameSpanish: string | undefined;
    densoCode: string | undefined;
    satCode: string | undefined;
    segroveCode: string | undefined;
    fullName: string | undefined;
    isActive: boolean;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    departmentIds: number[] | undefined;
    plantIds: number[] | undefined;
    departments: DepartmentUserDto[] | undefined;
    plants: PlantUserDto[] | undefined;
    employeeId: number | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
            if (Array.isArray(_data["departmentIds"])) {
                this.departmentIds = [] as any;
                for (let item of _data["departmentIds"])
                    this.departmentIds.push(item);
            }
            if (Array.isArray(_data["plantIds"])) {
                this.plantIds = [] as any;
                for (let item of _data["plantIds"])
                    this.plantIds.push(item);
            }
            if (Array.isArray(_data["departments"])) {
                this.departments = [] as any;
                for (let item of _data["departments"])
                    this.departments.push(DepartmentUserDto.fromJS(item));
            }
            if (Array.isArray(_data["plants"])) {
                this.plants = [] as any;
                for (let item of _data["plants"])
                    this.plants.push(PlantUserDto.fromJS(item));
            }
            this.employeeId = _data["employeeId"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        if (Array.isArray(this.departmentIds)) {
            data["departmentIds"] = [];
            for (let item of this.departmentIds)
                data["departmentIds"].push(item);
        }
        if (Array.isArray(this.plantIds)) {
            data["plantIds"] = [];
            for (let item of this.plantIds)
                data["plantIds"].push(item);
        }
        if (Array.isArray(this.departments)) {
            data["departments"] = [];
            for (let item of this.departments)
                data["departments"].push(item.toJSON());
        }
        if (Array.isArray(this.plants)) {
            data["plants"] = [];
            for (let item of this.plants)
                data["plants"].push(item.toJSON());
        }
        data["employeeId"] = this.employeeId;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
    departmentIds: number[] | undefined;
    plantIds: number[] | undefined;
    departments: DepartmentUserDto[] | undefined;
    plants: PlantUserDto[] | undefined;
    employeeId: number | undefined;
}

export class CreateUsersFromEmployeesInput implements ICreateUsersFromEmployeesInput {
    tenantId: number;
    employeeInternalIds: number[] | undefined;

    constructor(data?: ICreateUsersFromEmployeesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["employeeInternalIds"])) {
                this.employeeInternalIds = [] as any;
                for (let item of _data["employeeInternalIds"])
                    this.employeeInternalIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUsersFromEmployeesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUsersFromEmployeesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.employeeInternalIds)) {
            data["employeeInternalIds"] = [];
            for (let item of this.employeeInternalIds)
                data["employeeInternalIds"].push(item);
        }
        return data;
    }

    clone(): CreateUsersFromEmployeesInput {
        const json = this.toJSON();
        let result = new CreateUsersFromEmployeesInput();
        result.init(json);
        return result;
    }
}

export interface ICreateUsersFromEmployeesInput {
    tenantId: number;
    employeeInternalIds: number[] | undefined;
}

export class CurrencyDto implements ICurrencyDto {
    id: number | undefined;
    code: string | undefined;
    densoCode: string | undefined;
    name: string | undefined;
    isActive: boolean;
    fullName: string | undefined;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.densoCode = _data["densoCode"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["densoCode"] = this.densoCode;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): CurrencyDto {
        const json = this.toJSON();
        let result = new CurrencyDto();
        result.init(json);
        return result;
    }
}

export interface ICurrencyDto {
    id: number | undefined;
    code: string | undefined;
    densoCode: string | undefined;
    name: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
}

export class CurrentCarrierServicesDto implements ICurrentCarrierServicesDto {
    carrierId: number;
    serviceId: number;
    serviceName: string | undefined;
    isActive: boolean;
    ground: boolean;
    air: boolean;
    sea: boolean;

    constructor(data?: ICurrentCarrierServicesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.carrierId = _data["carrierId"];
            this.serviceId = _data["serviceId"];
            this.serviceName = _data["serviceName"];
            this.isActive = _data["isActive"];
            this.ground = _data["ground"];
            this.air = _data["air"];
            this.sea = _data["sea"];
        }
    }

    static fromJS(data: any): CurrentCarrierServicesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentCarrierServicesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["carrierId"] = this.carrierId;
        data["serviceId"] = this.serviceId;
        data["serviceName"] = this.serviceName;
        data["isActive"] = this.isActive;
        data["ground"] = this.ground;
        data["air"] = this.air;
        data["sea"] = this.sea;
        return data;
    }

    clone(): CurrentCarrierServicesDto {
        const json = this.toJSON();
        let result = new CurrentCarrierServicesDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentCarrierServicesDto {
    carrierId: number;
    serviceId: number;
    serviceName: string | undefined;
    isActive: boolean;
    ground: boolean;
    air: boolean;
    sea: boolean;
}

export class CustomerDto implements ICustomerDto {
    id: number | undefined;
    densoCustomerId: number | undefined;
    name: string | undefined;
    rfc: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    addressLine4: string | undefined;
    payment: boolean;
    isActive: boolean;
    contact: string | undefined;
    phone: string | undefined;
    fedexCta: string | undefined;
    plants: CustomerPlantDto[] | undefined;
    state: string | undefined;
    country: string | undefined;
    zipCode: string | undefined;
    taxId: string | undefined;
    fullName: string | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.densoCustomerId = _data["densoCustomerId"];
            this.name = _data["name"];
            this.rfc = _data["rfc"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.addressLine4 = _data["addressLine4"];
            this.payment = _data["payment"];
            this.isActive = _data["isActive"];
            this.contact = _data["contact"];
            this.phone = _data["phone"];
            this.fedexCta = _data["fedexCta"];
            if (Array.isArray(_data["plants"])) {
                this.plants = [] as any;
                for (let item of _data["plants"])
                    this.plants.push(CustomerPlantDto.fromJS(item));
            }
            this.state = _data["state"];
            this.country = _data["country"];
            this.zipCode = _data["zipCode"];
            this.taxId = _data["taxId"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["densoCustomerId"] = this.densoCustomerId;
        data["name"] = this.name;
        data["rfc"] = this.rfc;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["addressLine4"] = this.addressLine4;
        data["payment"] = this.payment;
        data["isActive"] = this.isActive;
        data["contact"] = this.contact;
        data["phone"] = this.phone;
        data["fedexCta"] = this.fedexCta;
        if (Array.isArray(this.plants)) {
            data["plants"] = [];
            for (let item of this.plants)
                data["plants"].push(item.toJSON());
        }
        data["state"] = this.state;
        data["country"] = this.country;
        data["zipCode"] = this.zipCode;
        data["taxId"] = this.taxId;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): CustomerDto {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto {
    id: number | undefined;
    densoCustomerId: number | undefined;
    name: string | undefined;
    rfc: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    addressLine4: string | undefined;
    payment: boolean;
    isActive: boolean;
    contact: string | undefined;
    phone: string | undefined;
    fedexCta: string | undefined;
    plants: CustomerPlantDto[] | undefined;
    state: string | undefined;
    country: string | undefined;
    zipCode: string | undefined;
    taxId: string | undefined;
    fullName: string | undefined;
}

export class CustomerPlantContactDto implements ICustomerPlantContactDto {
    id: number | undefined;
    customerPlantId: number;
    contactName: string | undefined;
    phoneNumber: string | undefined;
    departmentOrSection: string | undefined;
    netNumber: string | undefined;
    isActive: boolean;

    constructor(data?: ICustomerPlantContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerPlantId = _data["customerPlantId"];
            this.contactName = _data["contactName"];
            this.phoneNumber = _data["phoneNumber"];
            this.departmentOrSection = _data["departmentOrSection"];
            this.netNumber = _data["netNumber"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CustomerPlantContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPlantContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerPlantId"] = this.customerPlantId;
        data["contactName"] = this.contactName;
        data["phoneNumber"] = this.phoneNumber;
        data["departmentOrSection"] = this.departmentOrSection;
        data["netNumber"] = this.netNumber;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CustomerPlantContactDto {
        const json = this.toJSON();
        let result = new CustomerPlantContactDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerPlantContactDto {
    id: number | undefined;
    customerPlantId: number;
    contactName: string | undefined;
    phoneNumber: string | undefined;
    departmentOrSection: string | undefined;
    netNumber: string | undefined;
    isActive: boolean;
}

export class CustomerPlantDto implements ICustomerPlantDto {
    id: number | undefined;
    customerId: number;
    name: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    addressLine4: string | undefined;
    rfc: string | undefined;
    state: string | undefined;
    country: string | undefined;
    zipCode: string | undefined;
    taxId: string | undefined;
    isActive: boolean;
    shipToNumber: number;
    fullName: string | undefined;
    contacts: CustomerPlantContactDto[] | undefined;

    constructor(data?: ICustomerPlantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.name = _data["name"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.addressLine4 = _data["addressLine4"];
            this.rfc = _data["rfc"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.zipCode = _data["zipCode"];
            this.taxId = _data["taxId"];
            this.isActive = _data["isActive"];
            this.shipToNumber = _data["shipToNumber"];
            this.fullName = _data["fullName"];
            if (Array.isArray(_data["contacts"])) {
                this.contacts = [] as any;
                for (let item of _data["contacts"])
                    this.contacts.push(CustomerPlantContactDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerPlantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPlantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["name"] = this.name;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["addressLine4"] = this.addressLine4;
        data["rfc"] = this.rfc;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zipCode"] = this.zipCode;
        data["taxId"] = this.taxId;
        data["isActive"] = this.isActive;
        data["shipToNumber"] = this.shipToNumber;
        data["fullName"] = this.fullName;
        if (Array.isArray(this.contacts)) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        return data;
    }

    clone(): CustomerPlantDto {
        const json = this.toJSON();
        let result = new CustomerPlantDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerPlantDto {
    id: number | undefined;
    customerId: number;
    name: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    addressLine4: string | undefined;
    rfc: string | undefined;
    state: string | undefined;
    country: string | undefined;
    zipCode: string | undefined;
    taxId: string | undefined;
    isActive: boolean;
    shipToNumber: number;
    fullName: string | undefined;
    contacts: CustomerPlantContactDto[] | undefined;
}

export class DensoAS400SettingsEditDto implements IDensoAS400SettingsEditDto {
    dataSource: string | undefined;
    userID: string | undefined;
    password: string | undefined;

    constructor(data?: IDensoAS400SettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataSource = _data["dataSource"];
            this.userID = _data["userID"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): DensoAS400SettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DensoAS400SettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataSource"] = this.dataSource;
        data["userID"] = this.userID;
        data["password"] = this.password;
        return data;
    }

    clone(): DensoAS400SettingsEditDto {
        const json = this.toJSON();
        let result = new DensoAS400SettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IDensoAS400SettingsEditDto {
    dataSource: string | undefined;
    userID: string | undefined;
    password: string | undefined;
}

export class DensoGeneralSettingsEditDto implements IDensoGeneralSettingsEditDto {
    daysInAdvanceForNonWorkDaysNotification: string | undefined;
    defaulHelpUrl: string | undefined;

    constructor(data?: IDensoGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.daysInAdvanceForNonWorkDaysNotification = _data["daysInAdvanceForNonWorkDaysNotification"];
            this.defaulHelpUrl = _data["defaulHelpUrl"];
        }
    }

    static fromJS(data: any): DensoGeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DensoGeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["daysInAdvanceForNonWorkDaysNotification"] = this.daysInAdvanceForNonWorkDaysNotification;
        data["defaulHelpUrl"] = this.defaulHelpUrl;
        return data;
    }

    clone(): DensoGeneralSettingsEditDto {
        const json = this.toJSON();
        let result = new DensoGeneralSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IDensoGeneralSettingsEditDto {
    daysInAdvanceForNonWorkDaysNotification: string | undefined;
    defaulHelpUrl: string | undefined;
}

export class DensoInterfacesSettingsEditDto implements IDensoInterfacesSettingsEditDto {
    daysForReminders: string | undefined;
    emailsAddressToNotify: string | undefined;

    constructor(data?: IDensoInterfacesSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.daysForReminders = _data["daysForReminders"];
            this.emailsAddressToNotify = _data["emailsAddressToNotify"];
        }
    }

    static fromJS(data: any): DensoInterfacesSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DensoInterfacesSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["daysForReminders"] = this.daysForReminders;
        data["emailsAddressToNotify"] = this.emailsAddressToNotify;
        return data;
    }

    clone(): DensoInterfacesSettingsEditDto {
        const json = this.toJSON();
        let result = new DensoInterfacesSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IDensoInterfacesSettingsEditDto {
    daysForReminders: string | undefined;
    emailsAddressToNotify: string | undefined;
}

export class DensoSettingsEditDto implements IDensoSettingsEditDto {
    aS400: DensoAS400SettingsEditDto;
    interfaces: DensoInterfacesSettingsEditDto;
    general: DensoGeneralSettingsEditDto;

    constructor(data?: IDensoSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aS400 = _data["aS400"] ? DensoAS400SettingsEditDto.fromJS(_data["aS400"]) : <any>undefined;
            this.interfaces = _data["interfaces"] ? DensoInterfacesSettingsEditDto.fromJS(_data["interfaces"]) : <any>undefined;
            this.general = _data["general"] ? DensoGeneralSettingsEditDto.fromJS(_data["general"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DensoSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DensoSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aS400"] = this.aS400 ? this.aS400.toJSON() : <any>undefined;
        data["interfaces"] = this.interfaces ? this.interfaces.toJSON() : <any>undefined;
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        return data;
    }

    clone(): DensoSettingsEditDto {
        const json = this.toJSON();
        let result = new DensoSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IDensoSettingsEditDto {
    aS400: DensoAS400SettingsEditDto;
    interfaces: DensoInterfacesSettingsEditDto;
    general: DensoGeneralSettingsEditDto;
}

export class DepartmentByUserDto implements IDepartmentByUserDto {
    departmentId: number;
    departmentName: string | undefined;
    userId: number;
    isSupervisor: boolean;
    fullName: string | undefined;

    constructor(data?: IDepartmentByUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentId = _data["departmentId"];
            this.departmentName = _data["departmentName"];
            this.userId = _data["userId"];
            this.isSupervisor = _data["isSupervisor"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): DepartmentByUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentByUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentId"] = this.departmentId;
        data["departmentName"] = this.departmentName;
        data["userId"] = this.userId;
        data["isSupervisor"] = this.isSupervisor;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): DepartmentByUserDto {
        const json = this.toJSON();
        let result = new DepartmentByUserDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentByUserDto {
    departmentId: number;
    departmentName: string | undefined;
    userId: number;
    isSupervisor: boolean;
    fullName: string | undefined;
}

export class DepartmentDto implements IDepartmentDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean;
    totalUsers: number;
    fullName: string | undefined;

    constructor(data?: IDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.totalUsers = _data["totalUsers"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): DepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["totalUsers"] = this.totalUsers;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): DepartmentDto {
        const json = this.toJSON();
        let result = new DepartmentDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean;
    totalUsers: number;
    fullName: string | undefined;
}

export class DepartmentUserDto implements IDepartmentUserDto {
    id: number;
    departmentId: number;
    isSupervisor: boolean;
    departmentName: string | undefined;

    constructor(data?: IDepartmentUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.departmentId = _data["departmentId"];
            this.isSupervisor = _data["isSupervisor"];
            this.departmentName = _data["departmentName"];
        }
    }

    static fromJS(data: any): DepartmentUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["departmentId"] = this.departmentId;
        data["isSupervisor"] = this.isSupervisor;
        data["departmentName"] = this.departmentName;
        return data;
    }

    clone(): DepartmentUserDto {
        const json = this.toJSON();
        let result = new DepartmentUserDto();
        result.init(json);
        return result;
    }
}

export interface IDepartmentUserDto {
    id: number;
    departmentId: number;
    isSupervisor: boolean;
    departmentName: string | undefined;
}

export class DocumentStatusDto implements IDocumentStatusDto {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IDocumentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DocumentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): DocumentStatusDto {
        const json = this.toJSON();
        let result = new DocumentStatusDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentStatusDto {
    id: number | undefined;
    name: string | undefined;
}

export class DocumentTypeDto implements IDocumentTypeDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean;
    fullName: string | undefined;

    constructor(data?: IDocumentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): DocumentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): DocumentTypeDto {
        const json = this.toJSON();
        let result = new DocumentTypeDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentTypeDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
}

export class EmployeeDto implements IEmployeeDto {
    id: number | undefined;
    densoEmployeeId: number;
    credential: string | undefined;
    name: string | undefined;
    surnames: string | undefined;
    rfc: string | undefined;
    birthDate: moment.Moment | undefined;
    nss: string | undefined;
    curp: string | undefined;
    departmentId: number | undefined;
    departmentName: string | undefined;
    typeId: number | undefined;
    employeeType: string | undefined;
    levelId: number | undefined;
    employeeLevel: string | undefined;
    plantId: number | undefined;
    plantName: string | undefined;
    entryDate: moment.Moment;
    positionId: number | undefined;
    employeePosition: string | undefined;
    extras: boolean;
    notRequiredAHE: boolean;
    supervisor: boolean;
    subsidy: boolean;
    positionLevel: boolean;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    addressLine4: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    fullName: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.densoEmployeeId = _data["densoEmployeeId"];
            this.credential = _data["credential"];
            this.name = _data["name"];
            this.surnames = _data["surnames"];
            this.rfc = _data["rfc"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.nss = _data["nss"];
            this.curp = _data["curp"];
            this.departmentId = _data["departmentId"];
            this.departmentName = _data["departmentName"];
            this.typeId = _data["typeId"];
            this.employeeType = _data["employeeType"];
            this.levelId = _data["levelId"];
            this.employeeLevel = _data["employeeLevel"];
            this.plantId = _data["plantId"];
            this.plantName = _data["plantName"];
            this.entryDate = _data["entryDate"] ? moment(_data["entryDate"].toString()) : <any>undefined;
            this.positionId = _data["positionId"];
            this.employeePosition = _data["employeePosition"];
            this.extras = _data["extras"];
            this.notRequiredAHE = _data["notRequiredAHE"];
            this.supervisor = _data["supervisor"];
            this.subsidy = _data["subsidy"];
            this.positionLevel = _data["positionLevel"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.addressLine4 = _data["addressLine4"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["densoEmployeeId"] = this.densoEmployeeId;
        data["credential"] = this.credential;
        data["name"] = this.name;
        data["surnames"] = this.surnames;
        data["rfc"] = this.rfc;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["nss"] = this.nss;
        data["curp"] = this.curp;
        data["departmentId"] = this.departmentId;
        data["departmentName"] = this.departmentName;
        data["typeId"] = this.typeId;
        data["employeeType"] = this.employeeType;
        data["levelId"] = this.levelId;
        data["employeeLevel"] = this.employeeLevel;
        data["plantId"] = this.plantId;
        data["plantName"] = this.plantName;
        data["entryDate"] = this.entryDate ? this.entryDate.toISOString() : <any>undefined;
        data["positionId"] = this.positionId;
        data["employeePosition"] = this.employeePosition;
        data["extras"] = this.extras;
        data["notRequiredAHE"] = this.notRequiredAHE;
        data["supervisor"] = this.supervisor;
        data["subsidy"] = this.subsidy;
        data["positionLevel"] = this.positionLevel;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["addressLine4"] = this.addressLine4;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): EmployeeDto {
        const json = this.toJSON();
        let result = new EmployeeDto();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDto {
    id: number | undefined;
    densoEmployeeId: number;
    credential: string | undefined;
    name: string | undefined;
    surnames: string | undefined;
    rfc: string | undefined;
    birthDate: moment.Moment | undefined;
    nss: string | undefined;
    curp: string | undefined;
    departmentId: number | undefined;
    departmentName: string | undefined;
    typeId: number | undefined;
    employeeType: string | undefined;
    levelId: number | undefined;
    employeeLevel: string | undefined;
    plantId: number | undefined;
    plantName: string | undefined;
    entryDate: moment.Moment;
    positionId: number | undefined;
    employeePosition: string | undefined;
    extras: boolean;
    notRequiredAHE: boolean;
    supervisor: boolean;
    subsidy: boolean;
    positionLevel: boolean;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    addressLine4: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
}

export class EmployeeLevel implements IEmployeeLevel {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    level: string | undefined;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IEmployeeLevel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.level = _data["level"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EmployeeLevel {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeLevel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["level"] = this.level;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): EmployeeLevel {
        const json = this.toJSON();
        let result = new EmployeeLevel();
        result.init(json);
        return result;
    }
}

export interface IEmployeeLevel {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    level: string | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class EmployeeOptionsDto implements IEmployeeOptionsDto {
    types: EmployeeType[] | undefined;
    levels: EmployeeLevel[] | undefined;
    positions: EmployeePosition[] | undefined;
    departments: DepartmentDto[] | undefined;
    plants: PlantDto[] | undefined;

    constructor(data?: IEmployeeOptionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types.push(EmployeeType.fromJS(item));
            }
            if (Array.isArray(_data["levels"])) {
                this.levels = [] as any;
                for (let item of _data["levels"])
                    this.levels.push(EmployeeLevel.fromJS(item));
            }
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions.push(EmployeePosition.fromJS(item));
            }
            if (Array.isArray(_data["departments"])) {
                this.departments = [] as any;
                for (let item of _data["departments"])
                    this.departments.push(DepartmentDto.fromJS(item));
            }
            if (Array.isArray(_data["plants"])) {
                this.plants = [] as any;
                for (let item of _data["plants"])
                    this.plants.push(PlantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeOptionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeOptionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item.toJSON());
        }
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item.toJSON());
        }
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item.toJSON());
        }
        if (Array.isArray(this.departments)) {
            data["departments"] = [];
            for (let item of this.departments)
                data["departments"].push(item.toJSON());
        }
        if (Array.isArray(this.plants)) {
            data["plants"] = [];
            for (let item of this.plants)
                data["plants"].push(item.toJSON());
        }
        return data;
    }

    clone(): EmployeeOptionsDto {
        const json = this.toJSON();
        let result = new EmployeeOptionsDto();
        result.init(json);
        return result;
    }
}

export interface IEmployeeOptionsDto {
    types: EmployeeType[] | undefined;
    levels: EmployeeLevel[] | undefined;
    positions: EmployeePosition[] | undefined;
    departments: DepartmentDto[] | undefined;
    plants: PlantDto[] | undefined;
}

export class EmployeePosition implements IEmployeePosition {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IEmployeePosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EmployeePosition {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeePosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): EmployeePosition {
        const json = this.toJSON();
        let result = new EmployeePosition();
        result.init(json);
        return result;
    }
}

export interface IEmployeePosition {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class EmployeeType implements IEmployeeType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IEmployeeType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EmployeeType {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): EmployeeType {
        const json = this.toJSON();
        let result = new EmployeeType();
        result.init(json);
        return result;
    }
}

export interface IEmployeeType {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class FileDto implements IFileDto {
    id: number;
    entityType: string | undefined;
    entityId: number;
    guid: string;
    name: string | undefined;
    extension: string | undefined;
    length: number;
    contentType: string | undefined;
    creationTime: moment.Moment;
    url: string | undefined;
    uploadedBy: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.extension = _data["extension"];
            this.length = _data["length"];
            this.contentType = _data["contentType"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.uploadedBy = _data["uploadedBy"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["extension"] = this.extension;
        data["length"] = this.length;
        data["contentType"] = this.contentType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["uploadedBy"] = this.uploadedBy;
        return data;
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    id: number;
    entityType: string | undefined;
    entityId: number;
    guid: string;
    name: string | undefined;
    extension: string | undefined;
    length: number;
    contentType: string | undefined;
    creationTime: moment.Moment;
    url: string | undefined;
    uploadedBy: string | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class GetHotSheetInput implements IGetHotSheetInput {
    userId: number | undefined;
    plannerCode: string | undefined;
    supplierCode: string | undefined;
    partNumber: string | undefined;
    transportModeId: number | undefined;
    statusId: number | undefined;
    shortageShiftId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    statusHS: number;

    constructor(data?: IGetHotSheetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.plannerCode = _data["plannerCode"];
            this.supplierCode = _data["supplierCode"];
            this.partNumber = _data["partNumber"];
            this.transportModeId = _data["transportModeId"];
            this.statusId = _data["statusId"];
            this.shortageShiftId = _data["shortageShiftId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.statusHS = _data["statusHS"];
        }
    }

    static fromJS(data: any): GetHotSheetInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetHotSheetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["plannerCode"] = this.plannerCode;
        data["supplierCode"] = this.supplierCode;
        data["partNumber"] = this.partNumber;
        data["transportModeId"] = this.transportModeId;
        data["statusId"] = this.statusId;
        data["shortageShiftId"] = this.shortageShiftId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["statusHS"] = this.statusHS;
        return data;
    }

    clone(): GetHotSheetInput {
        const json = this.toJSON();
        let result = new GetHotSheetInput();
        result.init(json);
        return result;
    }
}

export interface IGetHotSheetInput {
    userId: number | undefined;
    plannerCode: string | undefined;
    supplierCode: string | undefined;
    partNumber: string | undefined;
    transportModeId: number | undefined;
    statusId: number | undefined;
    shortageShiftId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    statusHS: number;
}

export class GetPurchaseOrdersInput implements IGetPurchaseOrdersInput {
    userId: number | undefined;
    plannerCode: string | undefined;
    supplierCode: string | undefined;
    partNumber: string | undefined;
    statusId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    statusHS: number;

    constructor(data?: IGetPurchaseOrdersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.plannerCode = _data["plannerCode"];
            this.supplierCode = _data["supplierCode"];
            this.partNumber = _data["partNumber"];
            this.statusId = _data["statusId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.statusHS = _data["statusHS"];
        }
    }

    static fromJS(data: any): GetPurchaseOrdersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPurchaseOrdersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["plannerCode"] = this.plannerCode;
        data["supplierCode"] = this.supplierCode;
        data["partNumber"] = this.partNumber;
        data["statusId"] = this.statusId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["statusHS"] = this.statusHS;
        return data;
    }

    clone(): GetPurchaseOrdersInput {
        const json = this.toJSON();
        let result = new GetPurchaseOrdersInput();
        result.init(json);
        return result;
    }
}

export interface IGetPurchaseOrdersInput {
    userId: number | undefined;
    plannerCode: string | undefined;
    supplierCode: string | undefined;
    partNumber: string | undefined;
    statusId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    statusHS: number;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetStarSheetInput implements IGetStarSheetInput {
    userId: number | undefined;
    plannerCode: string | undefined;
    supplierCode: string | undefined;
    partNumber: string | undefined;
    transportModeId: number | undefined;
    statusId: number | undefined;
    shortageShiftId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    statusHS: number;

    constructor(data?: IGetStarSheetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.plannerCode = _data["plannerCode"];
            this.supplierCode = _data["supplierCode"];
            this.partNumber = _data["partNumber"];
            this.transportModeId = _data["transportModeId"];
            this.statusId = _data["statusId"];
            this.shortageShiftId = _data["shortageShiftId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.statusHS = _data["statusHS"];
        }
    }

    static fromJS(data: any): GetStarSheetInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStarSheetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["plannerCode"] = this.plannerCode;
        data["supplierCode"] = this.supplierCode;
        data["partNumber"] = this.partNumber;
        data["transportModeId"] = this.transportModeId;
        data["statusId"] = this.statusId;
        data["shortageShiftId"] = this.shortageShiftId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["statusHS"] = this.statusHS;
        return data;
    }

    clone(): GetStarSheetInput {
        const json = this.toJSON();
        let result = new GetStarSheetInput();
        result.init(json);
        return result;
    }
}

export interface IGetStarSheetInput {
    userId: number | undefined;
    plannerCode: string | undefined;
    supplierCode: string | undefined;
    partNumber: string | undefined;
    transportModeId: number | undefined;
    statusId: number | undefined;
    shortageShiftId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    statusHS: number;
}

export class HelpInfoDto implements IHelpInfoDto {
    id: number | undefined;
    helpInfoFieldId: number;
    helpInfoField: HelpInfoFieldDto;
    helpTextEnglish: string | undefined;
    helpTextSpanish: string | undefined;
    isActive: boolean;

    constructor(data?: IHelpInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.helpInfoFieldId = _data["helpInfoFieldId"];
            this.helpInfoField = _data["helpInfoField"] ? HelpInfoFieldDto.fromJS(_data["helpInfoField"]) : <any>undefined;
            this.helpTextEnglish = _data["helpTextEnglish"];
            this.helpTextSpanish = _data["helpTextSpanish"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): HelpInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new HelpInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["helpInfoFieldId"] = this.helpInfoFieldId;
        data["helpInfoField"] = this.helpInfoField ? this.helpInfoField.toJSON() : <any>undefined;
        data["helpTextEnglish"] = this.helpTextEnglish;
        data["helpTextSpanish"] = this.helpTextSpanish;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): HelpInfoDto {
        const json = this.toJSON();
        let result = new HelpInfoDto();
        result.init(json);
        return result;
    }
}

export interface IHelpInfoDto {
    id: number | undefined;
    helpInfoFieldId: number;
    helpInfoField: HelpInfoFieldDto;
    helpTextEnglish: string | undefined;
    helpTextSpanish: string | undefined;
    isActive: boolean;
}

export class HelpInfoFieldDto implements IHelpInfoFieldDto {
    id: number | undefined;
    fieldName: string | undefined;
    isActive: boolean;

    constructor(data?: IHelpInfoFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fieldName = _data["fieldName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): HelpInfoFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new HelpInfoFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fieldName"] = this.fieldName;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): HelpInfoFieldDto {
        const json = this.toJSON();
        let result = new HelpInfoFieldDto();
        result.init(json);
        return result;
    }
}

export interface IHelpInfoFieldDto {
    id: number | undefined;
    fieldName: string | undefined;
    isActive: boolean;
}

export enum HotSheetNotificationType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export class HotSheetReasonDto implements IHotSheetReasonDto {
    id: number | undefined;
    description: string | undefined;
    bNoticeRMARequired: boolean;
    pictureTechnicalInfoMakerModelSerialNumber: boolean;
    attachPurchaseOrder: boolean;
    technicalInfoPicture: boolean;
    accountingApprovalRequired: boolean;
    excludeTermOfPayment: boolean;
    remittence: boolean;
    noPayment: boolean;
    isActive: boolean;

    constructor(data?: IHotSheetReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.bNoticeRMARequired = _data["bNoticeRMARequired"];
            this.pictureTechnicalInfoMakerModelSerialNumber = _data["pictureTechnicalInfoMakerModelSerialNumber"];
            this.attachPurchaseOrder = _data["attachPurchaseOrder"];
            this.technicalInfoPicture = _data["technicalInfoPicture"];
            this.accountingApprovalRequired = _data["accountingApprovalRequired"];
            this.excludeTermOfPayment = _data["excludeTermOfPayment"];
            this.remittence = _data["remittence"];
            this.noPayment = _data["noPayment"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): HotSheetReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new HotSheetReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["bNoticeRMARequired"] = this.bNoticeRMARequired;
        data["pictureTechnicalInfoMakerModelSerialNumber"] = this.pictureTechnicalInfoMakerModelSerialNumber;
        data["attachPurchaseOrder"] = this.attachPurchaseOrder;
        data["technicalInfoPicture"] = this.technicalInfoPicture;
        data["accountingApprovalRequired"] = this.accountingApprovalRequired;
        data["excludeTermOfPayment"] = this.excludeTermOfPayment;
        data["remittence"] = this.remittence;
        data["noPayment"] = this.noPayment;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): HotSheetReasonDto {
        const json = this.toJSON();
        let result = new HotSheetReasonDto();
        result.init(json);
        return result;
    }
}

export interface IHotSheetReasonDto {
    id: number | undefined;
    description: string | undefined;
    bNoticeRMARequired: boolean;
    pictureTechnicalInfoMakerModelSerialNumber: boolean;
    attachPurchaseOrder: boolean;
    technicalInfoPicture: boolean;
    accountingApprovalRequired: boolean;
    excludeTermOfPayment: boolean;
    remittence: boolean;
    noPayment: boolean;
    isActive: boolean;
}

export class HotSheetReminderItem implements IHotSheetReminderItem {
    hotSheetShiptId: number;
    folio: string | undefined;
    creationDate: moment.Moment;
    creatorUserId: number;
    creatorFullName: string | undefined;
    documentTypeId: number;
    customerName: string | undefined;

    constructor(data?: IHotSheetReminderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hotSheetShiptId = _data["hotSheetShiptId"];
            this.folio = _data["folio"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.creatorFullName = _data["creatorFullName"];
            this.documentTypeId = _data["documentTypeId"];
            this.customerName = _data["customerName"];
        }
    }

    static fromJS(data: any): HotSheetReminderItem {
        data = typeof data === 'object' ? data : {};
        let result = new HotSheetReminderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hotSheetShiptId"] = this.hotSheetShiptId;
        data["folio"] = this.folio;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorFullName"] = this.creatorFullName;
        data["documentTypeId"] = this.documentTypeId;
        data["customerName"] = this.customerName;
        return data;
    }

    clone(): HotSheetReminderItem {
        const json = this.toJSON();
        let result = new HotSheetReminderItem();
        result.init(json);
        return result;
    }
}

export interface IHotSheetReminderItem {
    hotSheetShiptId: number;
    folio: string | undefined;
    creationDate: moment.Moment;
    creatorUserId: number;
    creatorFullName: string | undefined;
    documentTypeId: number;
    customerName: string | undefined;
}

export class HotSheetTermDto implements IHotSheetTermDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: IHotSheetTermDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): HotSheetTermDto {
        data = typeof data === 'object' ? data : {};
        let result = new HotSheetTermDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): HotSheetTermDto {
        const json = this.toJSON();
        let result = new HotSheetTermDto();
        result.init(json);
        return result;
    }
}

export interface IHotSheetTermDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    isActive: boolean;
}

export class HotSheetsCommetsDto implements IHotSheetsCommetsDto {
    id: number | undefined;
    hotSheetId: number;
    departmentId: number;
    department: string | undefined;
    comments: string | undefined;
    creatorUserId: number;
    creationTime: moment.Moment | undefined;
    creatorFullName: string | undefined;

    constructor(data?: IHotSheetsCommetsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hotSheetId = _data["hotSheetId"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"];
            this.comments = _data["comments"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorFullName = _data["creatorFullName"];
        }
    }

    static fromJS(data: any): HotSheetsCommetsDto {
        data = typeof data === 'object' ? data : {};
        let result = new HotSheetsCommetsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hotSheetId"] = this.hotSheetId;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department;
        data["comments"] = this.comments;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorFullName"] = this.creatorFullName;
        return data;
    }

    clone(): HotSheetsCommetsDto {
        const json = this.toJSON();
        let result = new HotSheetsCommetsDto();
        result.init(json);
        return result;
    }
}

export interface IHotSheetsCommetsDto {
    id: number | undefined;
    hotSheetId: number;
    departmentId: number;
    department: string | undefined;
    comments: string | undefined;
    creatorUserId: number;
    creationTime: moment.Moment | undefined;
    creatorFullName: string | undefined;
}

export class HotSheetsDto implements IHotSheetsDto {
    id: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number | undefined;
    diaStockIn: number | undefined;
    diaLocation: string | undefined;
    cigmaReceived: number | undefined;
    transportModeId: number | undefined;
    transportMode: TransportModeDto;
    deliveryOrder: number | undefined;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheet: StatusHotSheetDto;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShift: ShortageShiftDto;
    shortage: string | undefined;
    asn: number;
    pcComments: string | undefined;

    constructor(data?: IHotSheetsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.plannerCode = _data["plannerCode"];
            this.plannerName = _data["plannerName"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.partNumber = _data["partNumber"];
            this.partDescription = _data["partDescription"];
            this.inTransitQty = _data["inTransitQty"];
            this.diaStockIn = _data["diaStockIn"];
            this.diaLocation = _data["diaLocation"];
            this.cigmaReceived = _data["cigmaReceived"];
            this.transportModeId = _data["transportModeId"];
            this.transportMode = _data["transportMode"] ? TransportModeDto.fromJS(_data["transportMode"]) : <any>undefined;
            this.deliveryOrder = _data["deliveryOrder"];
            this.trafficContainerFX = _data["trafficContainerFX"];
            this.unitNumber = _data["unitNumber"];
            this.etaDNMX = _data["etaDNMX"] ? moment(_data["etaDNMX"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.statusHotSheet = _data["statusHotSheet"] ? StatusHotSheetDto.fromJS(_data["statusHotSheet"]) : <any>undefined;
            this.realShortageDate = _data["realShortageDate"] ? moment(_data["realShortageDate"].toString()) : <any>undefined;
            this.shortageShiftId = _data["shortageShiftId"];
            this.shortageShift = _data["shortageShift"] ? ShortageShiftDto.fromJS(_data["shortageShift"]) : <any>undefined;
            this.shortage = _data["shortage"];
            this.asn = _data["asn"];
            this.pcComments = _data["pcComments"];
        }
    }

    static fromJS(data: any): HotSheetsDto {
        data = typeof data === 'object' ? data : {};
        let result = new HotSheetsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["plannerCode"] = this.plannerCode;
        data["plannerName"] = this.plannerName;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["partNumber"] = this.partNumber;
        data["partDescription"] = this.partDescription;
        data["inTransitQty"] = this.inTransitQty;
        data["diaStockIn"] = this.diaStockIn;
        data["diaLocation"] = this.diaLocation;
        data["cigmaReceived"] = this.cigmaReceived;
        data["transportModeId"] = this.transportModeId;
        data["transportMode"] = this.transportMode ? this.transportMode.toJSON() : <any>undefined;
        data["deliveryOrder"] = this.deliveryOrder;
        data["trafficContainerFX"] = this.trafficContainerFX;
        data["unitNumber"] = this.unitNumber;
        data["etaDNMX"] = this.etaDNMX ? this.etaDNMX.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["statusHotSheet"] = this.statusHotSheet ? this.statusHotSheet.toJSON() : <any>undefined;
        data["realShortageDate"] = this.realShortageDate ? this.realShortageDate.toISOString() : <any>undefined;
        data["shortageShiftId"] = this.shortageShiftId;
        data["shortageShift"] = this.shortageShift ? this.shortageShift.toJSON() : <any>undefined;
        data["shortage"] = this.shortage;
        data["asn"] = this.asn;
        data["pcComments"] = this.pcComments;
        return data;
    }

    clone(): HotSheetsDto {
        const json = this.toJSON();
        let result = new HotSheetsDto();
        result.init(json);
        return result;
    }
}

export interface IHotSheetsDto {
    id: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number | undefined;
    diaStockIn: number | undefined;
    diaLocation: string | undefined;
    cigmaReceived: number | undefined;
    transportModeId: number | undefined;
    transportMode: TransportModeDto;
    deliveryOrder: number | undefined;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheet: StatusHotSheetDto;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShift: ShortageShiftDto;
    shortage: string | undefined;
    asn: number;
    pcComments: string | undefined;
}

export class HotSheetsItemDetailDto implements IHotSheetsItemDetailDto {
    hotSheetId: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplerName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number;
    diaStockIn: number;
    diaLocation: string | undefined;
    cigmaReceived: number;
    transportModeId: number | undefined;
    transportModeName: string | undefined;
    deliveryOrder: number;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheetName: string | undefined;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShiftName: string | undefined;
    shortage: string | undefined;
    shortageVal: string | undefined;
    pcComments: string | undefined;
    files: FileDto[] | undefined;

    constructor(data?: IHotSheetsItemDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hotSheetId = _data["hotSheetId"];
            this.plannerCode = _data["plannerCode"];
            this.plannerName = _data["plannerName"];
            this.supplierCode = _data["supplierCode"];
            this.supplerName = _data["supplerName"];
            this.partNumber = _data["partNumber"];
            this.partDescription = _data["partDescription"];
            this.inTransitQty = _data["inTransitQty"];
            this.diaStockIn = _data["diaStockIn"];
            this.diaLocation = _data["diaLocation"];
            this.cigmaReceived = _data["cigmaReceived"];
            this.transportModeId = _data["transportModeId"];
            this.transportModeName = _data["transportModeName"];
            this.deliveryOrder = _data["deliveryOrder"];
            this.trafficContainerFX = _data["trafficContainerFX"];
            this.unitNumber = _data["unitNumber"];
            this.etaDNMX = _data["etaDNMX"] ? moment(_data["etaDNMX"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.statusHotSheetName = _data["statusHotSheetName"];
            this.realShortageDate = _data["realShortageDate"] ? moment(_data["realShortageDate"].toString()) : <any>undefined;
            this.shortageShiftId = _data["shortageShiftId"];
            this.shortageShiftName = _data["shortageShiftName"];
            this.shortage = _data["shortage"];
            this.shortageVal = _data["shortageVal"];
            this.pcComments = _data["pcComments"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files.push(FileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HotSheetsItemDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new HotSheetsItemDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hotSheetId"] = this.hotSheetId;
        data["plannerCode"] = this.plannerCode;
        data["plannerName"] = this.plannerName;
        data["supplierCode"] = this.supplierCode;
        data["supplerName"] = this.supplerName;
        data["partNumber"] = this.partNumber;
        data["partDescription"] = this.partDescription;
        data["inTransitQty"] = this.inTransitQty;
        data["diaStockIn"] = this.diaStockIn;
        data["diaLocation"] = this.diaLocation;
        data["cigmaReceived"] = this.cigmaReceived;
        data["transportModeId"] = this.transportModeId;
        data["transportModeName"] = this.transportModeName;
        data["deliveryOrder"] = this.deliveryOrder;
        data["trafficContainerFX"] = this.trafficContainerFX;
        data["unitNumber"] = this.unitNumber;
        data["etaDNMX"] = this.etaDNMX ? this.etaDNMX.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["statusHotSheetName"] = this.statusHotSheetName;
        data["realShortageDate"] = this.realShortageDate ? this.realShortageDate.toISOString() : <any>undefined;
        data["shortageShiftId"] = this.shortageShiftId;
        data["shortageShiftName"] = this.shortageShiftName;
        data["shortage"] = this.shortage;
        data["shortageVal"] = this.shortageVal;
        data["pcComments"] = this.pcComments;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }

    clone(): HotSheetsItemDetailDto {
        const json = this.toJSON();
        let result = new HotSheetsItemDetailDto();
        result.init(json);
        return result;
    }
}

export interface IHotSheetsItemDetailDto {
    hotSheetId: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplerName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number;
    diaStockIn: number;
    diaLocation: string | undefined;
    cigmaReceived: number;
    transportModeId: number | undefined;
    transportModeName: string | undefined;
    deliveryOrder: number;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheetName: string | undefined;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShiftName: string | undefined;
    shortage: string | undefined;
    shortageVal: string | undefined;
    pcComments: string | undefined;
    files: FileDto[] | undefined;
}

export class HotSheetsItemDto implements IHotSheetsItemDto {
    hotSheetId: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number;
    diaStockIn: number;
    diaLocation: string | undefined;
    cigmaReceived: number;
    transportModeId: number | undefined;
    transportModeName: string | undefined;
    deliveryOrder: number;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheetName: string | undefined;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShiftName: string | undefined;
    shortage: string | undefined;
    shortageVal: string | undefined;
    asn: string | undefined;
    pcComments: string | undefined;
    creationDate: moment.Moment | undefined;
    existComment: number;

    constructor(data?: IHotSheetsItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hotSheetId = _data["hotSheetId"];
            this.plannerCode = _data["plannerCode"];
            this.plannerName = _data["plannerName"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.partNumber = _data["partNumber"];
            this.partDescription = _data["partDescription"];
            this.inTransitQty = _data["inTransitQty"];
            this.diaStockIn = _data["diaStockIn"];
            this.diaLocation = _data["diaLocation"];
            this.cigmaReceived = _data["cigmaReceived"];
            this.transportModeId = _data["transportModeId"];
            this.transportModeName = _data["transportModeName"];
            this.deliveryOrder = _data["deliveryOrder"];
            this.trafficContainerFX = _data["trafficContainerFX"];
            this.unitNumber = _data["unitNumber"];
            this.etaDNMX = _data["etaDNMX"] ? moment(_data["etaDNMX"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.statusHotSheetName = _data["statusHotSheetName"];
            this.realShortageDate = _data["realShortageDate"] ? moment(_data["realShortageDate"].toString()) : <any>undefined;
            this.shortageShiftId = _data["shortageShiftId"];
            this.shortageShiftName = _data["shortageShiftName"];
            this.shortage = _data["shortage"];
            this.shortageVal = _data["shortageVal"];
            this.asn = _data["asn"];
            this.pcComments = _data["pcComments"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.existComment = _data["existComment"];
        }
    }

    static fromJS(data: any): HotSheetsItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new HotSheetsItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hotSheetId"] = this.hotSheetId;
        data["plannerCode"] = this.plannerCode;
        data["plannerName"] = this.plannerName;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["partNumber"] = this.partNumber;
        data["partDescription"] = this.partDescription;
        data["inTransitQty"] = this.inTransitQty;
        data["diaStockIn"] = this.diaStockIn;
        data["diaLocation"] = this.diaLocation;
        data["cigmaReceived"] = this.cigmaReceived;
        data["transportModeId"] = this.transportModeId;
        data["transportModeName"] = this.transportModeName;
        data["deliveryOrder"] = this.deliveryOrder;
        data["trafficContainerFX"] = this.trafficContainerFX;
        data["unitNumber"] = this.unitNumber;
        data["etaDNMX"] = this.etaDNMX ? this.etaDNMX.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["statusHotSheetName"] = this.statusHotSheetName;
        data["realShortageDate"] = this.realShortageDate ? this.realShortageDate.toISOString() : <any>undefined;
        data["shortageShiftId"] = this.shortageShiftId;
        data["shortageShiftName"] = this.shortageShiftName;
        data["shortage"] = this.shortage;
        data["shortageVal"] = this.shortageVal;
        data["asn"] = this.asn;
        data["pcComments"] = this.pcComments;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["existComment"] = this.existComment;
        return data;
    }

    clone(): HotSheetsItemDto {
        const json = this.toJSON();
        let result = new HotSheetsItemDto();
        result.init(json);
        return result;
    }
}

export interface IHotSheetsItemDto {
    hotSheetId: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number;
    diaStockIn: number;
    diaLocation: string | undefined;
    cigmaReceived: number;
    transportModeId: number | undefined;
    transportModeName: string | undefined;
    deliveryOrder: number;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheetName: string | undefined;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShiftName: string | undefined;
    shortage: string | undefined;
    shortageVal: string | undefined;
    asn: string | undefined;
    pcComments: string | undefined;
    creationDate: moment.Moment | undefined;
    existComment: number;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class NoticeDto implements INoticeDto {
    id: number | undefined;
    message: string | undefined;
    noticeDay: moment.Moment;
    anticipationDays: number;
    isActive: boolean;

    constructor(data?: INoticeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.message = _data["message"];
            this.noticeDay = _data["noticeDay"] ? moment(_data["noticeDay"].toString()) : <any>undefined;
            this.anticipationDays = _data["anticipationDays"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): NoticeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["message"] = this.message;
        data["noticeDay"] = this.noticeDay ? this.noticeDay.toISOString() : <any>undefined;
        data["anticipationDays"] = this.anticipationDays;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): NoticeDto {
        const json = this.toJSON();
        let result = new NoticeDto();
        result.init(json);
        return result;
    }
}

export interface INoticeDto {
    id: number | undefined;
    message: string | undefined;
    noticeDay: moment.Moment;
    anticipationDays: number;
    isActive: boolean;
}

export class PackagingDto implements IPackagingDto {
    id: number | undefined;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: IPackagingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PackagingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackagingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PackagingDto {
        const json = this.toJSON();
        let result = new PackagingDto();
        result.init(json);
        return result;
    }
}

export interface IPackagingDto {
    id: number | undefined;
    description: string | undefined;
    isActive: boolean;
}

export class PaidByDto implements IPaidByDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean;
    paymentTerms: PaidByPaymentTermDto[] | undefined;
    hotSheetTerms: PaidByHotSheetTermDto[] | undefined;

    constructor(data?: IPaidByDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["paymentTerms"])) {
                this.paymentTerms = [] as any;
                for (let item of _data["paymentTerms"])
                    this.paymentTerms.push(PaidByPaymentTermDto.fromJS(item));
            }
            if (Array.isArray(_data["hotSheetTerms"])) {
                this.hotSheetTerms = [] as any;
                for (let item of _data["hotSheetTerms"])
                    this.hotSheetTerms.push(PaidByHotSheetTermDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaidByDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaidByDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.paymentTerms)) {
            data["paymentTerms"] = [];
            for (let item of this.paymentTerms)
                data["paymentTerms"].push(item.toJSON());
        }
        if (Array.isArray(this.hotSheetTerms)) {
            data["hotSheetTerms"] = [];
            for (let item of this.hotSheetTerms)
                data["hotSheetTerms"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaidByDto {
        const json = this.toJSON();
        let result = new PaidByDto();
        result.init(json);
        return result;
    }
}

export interface IPaidByDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean;
    paymentTerms: PaidByPaymentTermDto[] | undefined;
    hotSheetTerms: PaidByHotSheetTermDto[] | undefined;
}

export class PaidByHotSheetTermDto implements IPaidByHotSheetTermDto {
    id: number | undefined;
    paidById: number;
    hotSheetTermId: number;

    constructor(data?: IPaidByHotSheetTermDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paidById = _data["paidById"];
            this.hotSheetTermId = _data["hotSheetTermId"];
        }
    }

    static fromJS(data: any): PaidByHotSheetTermDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaidByHotSheetTermDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paidById"] = this.paidById;
        data["hotSheetTermId"] = this.hotSheetTermId;
        return data;
    }

    clone(): PaidByHotSheetTermDto {
        const json = this.toJSON();
        let result = new PaidByHotSheetTermDto();
        result.init(json);
        return result;
    }
}

export interface IPaidByHotSheetTermDto {
    id: number | undefined;
    paidById: number;
    hotSheetTermId: number;
}

export class PaidByPaymentTermDto implements IPaidByPaymentTermDto {
    id: number | undefined;
    paidById: number;
    paymentTermId: number;

    constructor(data?: IPaidByPaymentTermDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paidById = _data["paidById"];
            this.paymentTermId = _data["paymentTermId"];
        }
    }

    static fromJS(data: any): PaidByPaymentTermDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaidByPaymentTermDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paidById"] = this.paidById;
        data["paymentTermId"] = this.paymentTermId;
        return data;
    }

    clone(): PaidByPaymentTermDto {
        const json = this.toJSON();
        let result = new PaidByPaymentTermDto();
        result.init(json);
        return result;
    }
}

export interface IPaidByPaymentTermDto {
    id: number | undefined;
    paidById: number;
    paymentTermId: number;
}

export class PartNumberDto implements IPartNumberDto {
    id: number | undefined;
    number: string | undefined;
    description: string | undefined;
    descriptionSpanish: string | undefined;
    unitMeasureId: number;
    unitMeasure: UnitMeasureDto;
    productCodeSATId: number;
    productCodeSAT: ProductCodeSATDto;
    originCountryId: number | undefined;
    originCountry: string | undefined;
    fraction: string | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    fullNumber: string | undefined;
    weight: number | undefined;

    constructor(data?: IPartNumberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.description = _data["description"];
            this.descriptionSpanish = _data["descriptionSpanish"];
            this.unitMeasureId = _data["unitMeasureId"];
            this.unitMeasure = _data["unitMeasure"] ? UnitMeasureDto.fromJS(_data["unitMeasure"]) : <any>undefined;
            this.productCodeSATId = _data["productCodeSATId"];
            this.productCodeSAT = _data["productCodeSAT"] ? ProductCodeSATDto.fromJS(_data["productCodeSAT"]) : <any>undefined;
            this.originCountryId = _data["originCountryId"];
            this.originCountry = _data["originCountry"];
            this.fraction = _data["fraction"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.fullNumber = _data["fullNumber"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): PartNumberDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartNumberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["description"] = this.description;
        data["descriptionSpanish"] = this.descriptionSpanish;
        data["unitMeasureId"] = this.unitMeasureId;
        data["unitMeasure"] = this.unitMeasure ? this.unitMeasure.toJSON() : <any>undefined;
        data["productCodeSATId"] = this.productCodeSATId;
        data["productCodeSAT"] = this.productCodeSAT ? this.productCodeSAT.toJSON() : <any>undefined;
        data["originCountryId"] = this.originCountryId;
        data["originCountry"] = this.originCountry;
        data["fraction"] = this.fraction;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["fullNumber"] = this.fullNumber;
        data["weight"] = this.weight;
        return data;
    }

    clone(): PartNumberDto {
        const json = this.toJSON();
        let result = new PartNumberDto();
        result.init(json);
        return result;
    }
}

export interface IPartNumberDto {
    id: number | undefined;
    number: string | undefined;
    description: string | undefined;
    descriptionSpanish: string | undefined;
    unitMeasureId: number;
    unitMeasure: UnitMeasureDto;
    productCodeSATId: number;
    productCodeSAT: ProductCodeSATDto;
    originCountryId: number | undefined;
    originCountry: string | undefined;
    fraction: string | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    fullNumber: string | undefined;
    weight: number | undefined;
}

export class PartNumberForSelectDto implements IPartNumberForSelectDto {
    id: number;
    number: string | undefined;
    description: string | undefined;
    descriptionSpanish: string | undefined;
    originCountryId: number | undefined;
    fullNumber: string | undefined;
    isInternal: boolean;
    numberValue: string | undefined;
    unitPriceInternal: number | undefined;
    unitMeasureId: number | undefined;
    productCodeSATId: number | undefined;
    productSATCode: string | undefined;
    customerId: number | undefined;

    constructor(data?: IPartNumberForSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.description = _data["description"];
            this.descriptionSpanish = _data["descriptionSpanish"];
            this.originCountryId = _data["originCountryId"];
            this.fullNumber = _data["fullNumber"];
            this.isInternal = _data["isInternal"];
            this.numberValue = _data["numberValue"];
            this.unitPriceInternal = _data["unitPriceInternal"];
            this.unitMeasureId = _data["unitMeasureId"];
            this.productCodeSATId = _data["productCodeSATId"];
            this.productSATCode = _data["productSATCode"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): PartNumberForSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartNumberForSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["description"] = this.description;
        data["descriptionSpanish"] = this.descriptionSpanish;
        data["originCountryId"] = this.originCountryId;
        data["fullNumber"] = this.fullNumber;
        data["isInternal"] = this.isInternal;
        data["numberValue"] = this.numberValue;
        data["unitPriceInternal"] = this.unitPriceInternal;
        data["unitMeasureId"] = this.unitMeasureId;
        data["productCodeSATId"] = this.productCodeSATId;
        data["productSATCode"] = this.productSATCode;
        data["customerId"] = this.customerId;
        return data;
    }

    clone(): PartNumberForSelectDto {
        const json = this.toJSON();
        let result = new PartNumberForSelectDto();
        result.init(json);
        return result;
    }
}

export interface IPartNumberForSelectDto {
    id: number;
    number: string | undefined;
    description: string | undefined;
    descriptionSpanish: string | undefined;
    originCountryId: number | undefined;
    fullNumber: string | undefined;
    isInternal: boolean;
    numberValue: string | undefined;
    unitPriceInternal: number | undefined;
    unitMeasureId: number | undefined;
    productCodeSATId: number | undefined;
    productSATCode: string | undefined;
    customerId: number | undefined;
}

export class PartNumberInternalDto implements IPartNumberInternalDto {
    id: number | undefined;
    number: string | undefined;
    description: string | undefined;
    descriptionSpanish: string | undefined;
    unitMeasureId: number | undefined;
    unitMeasure: UnitMeasureDto;
    productCodeSATId: number | undefined;
    productCodeSAT: ProductCodeSATDto;
    originCountryId: number | undefined;
    originCountry: string | undefined;
    fraction: string | undefined;
    isActive: boolean;
    fullNumber: string | undefined;
    weight: number | undefined;
    price: number | undefined;

    constructor(data?: IPartNumberInternalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.description = _data["description"];
            this.descriptionSpanish = _data["descriptionSpanish"];
            this.unitMeasureId = _data["unitMeasureId"];
            this.unitMeasure = _data["unitMeasure"] ? UnitMeasureDto.fromJS(_data["unitMeasure"]) : <any>undefined;
            this.productCodeSATId = _data["productCodeSATId"];
            this.productCodeSAT = _data["productCodeSAT"] ? ProductCodeSATDto.fromJS(_data["productCodeSAT"]) : <any>undefined;
            this.originCountryId = _data["originCountryId"];
            this.originCountry = _data["originCountry"];
            this.fraction = _data["fraction"];
            this.isActive = _data["isActive"];
            this.fullNumber = _data["fullNumber"];
            this.weight = _data["weight"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): PartNumberInternalDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartNumberInternalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["description"] = this.description;
        data["descriptionSpanish"] = this.descriptionSpanish;
        data["unitMeasureId"] = this.unitMeasureId;
        data["unitMeasure"] = this.unitMeasure ? this.unitMeasure.toJSON() : <any>undefined;
        data["productCodeSATId"] = this.productCodeSATId;
        data["productCodeSAT"] = this.productCodeSAT ? this.productCodeSAT.toJSON() : <any>undefined;
        data["originCountryId"] = this.originCountryId;
        data["originCountry"] = this.originCountry;
        data["fraction"] = this.fraction;
        data["isActive"] = this.isActive;
        data["fullNumber"] = this.fullNumber;
        data["weight"] = this.weight;
        data["price"] = this.price;
        return data;
    }

    clone(): PartNumberInternalDto {
        const json = this.toJSON();
        let result = new PartNumberInternalDto();
        result.init(json);
        return result;
    }
}

export interface IPartNumberInternalDto {
    id: number | undefined;
    number: string | undefined;
    description: string | undefined;
    descriptionSpanish: string | undefined;
    unitMeasureId: number | undefined;
    unitMeasure: UnitMeasureDto;
    productCodeSATId: number | undefined;
    productCodeSAT: ProductCodeSATDto;
    originCountryId: number | undefined;
    originCountry: string | undefined;
    fraction: string | undefined;
    isActive: boolean;
    fullNumber: string | undefined;
    weight: number | undefined;
    price: number | undefined;
}

export class PartNumberInternalResXlsxDto implements IPartNumberInternalResXlsxDto {
    processDate: moment.Moment;
    counter: number;
    counterDel: number;
    counterUpd: number;
    counterIns: number;

    constructor(data?: IPartNumberInternalResXlsxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processDate = _data["processDate"] ? moment(_data["processDate"].toString()) : <any>undefined;
            this.counter = _data["counter"];
            this.counterDel = _data["counterDel"];
            this.counterUpd = _data["counterUpd"];
            this.counterIns = _data["counterIns"];
        }
    }

    static fromJS(data: any): PartNumberInternalResXlsxDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartNumberInternalResXlsxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDate"] = this.processDate ? this.processDate.toISOString() : <any>undefined;
        data["counter"] = this.counter;
        data["counterDel"] = this.counterDel;
        data["counterUpd"] = this.counterUpd;
        data["counterIns"] = this.counterIns;
        return data;
    }

    clone(): PartNumberInternalResXlsxDto {
        const json = this.toJSON();
        let result = new PartNumberInternalResXlsxDto();
        result.init(json);
        return result;
    }
}

export interface IPartNumberInternalResXlsxDto {
    processDate: moment.Moment;
    counter: number;
    counterDel: number;
    counterUpd: number;
    counterIns: number;
}

export class PartNumberInternalXlsxDto implements IPartNumberInternalXlsxDto {
    partNumber: string | undefined;
    descriptionInglish: string | undefined;
    descriptionSpanish: string | undefined;
    unitMeasureId: number | undefined;
    productCodeSATId: number | undefined;
    weight: number | undefined;
    originCountryId: string | undefined;
    fraction: string | undefined;

    constructor(data?: IPartNumberInternalXlsxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partNumber = _data["partNumber"];
            this.descriptionInglish = _data["descriptionInglish"];
            this.descriptionSpanish = _data["descriptionSpanish"];
            this.unitMeasureId = _data["unitMeasureId"];
            this.productCodeSATId = _data["productCodeSATId"];
            this.weight = _data["weight"];
            this.originCountryId = _data["originCountryId"];
            this.fraction = _data["fraction"];
        }
    }

    static fromJS(data: any): PartNumberInternalXlsxDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartNumberInternalXlsxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partNumber"] = this.partNumber;
        data["descriptionInglish"] = this.descriptionInglish;
        data["descriptionSpanish"] = this.descriptionSpanish;
        data["unitMeasureId"] = this.unitMeasureId;
        data["productCodeSATId"] = this.productCodeSATId;
        data["weight"] = this.weight;
        data["originCountryId"] = this.originCountryId;
        data["fraction"] = this.fraction;
        return data;
    }

    clone(): PartNumberInternalXlsxDto {
        const json = this.toJSON();
        let result = new PartNumberInternalXlsxDto();
        result.init(json);
        return result;
    }
}

export interface IPartNumberInternalXlsxDto {
    partNumber: string | undefined;
    descriptionInglish: string | undefined;
    descriptionSpanish: string | undefined;
    unitMeasureId: number | undefined;
    productCodeSATId: number | undefined;
    weight: number | undefined;
    originCountryId: string | undefined;
    fraction: string | undefined;
}

export class PartNumberPriceDto implements IPartNumberPriceDto {
    id: number | undefined;
    customerId: number;
    customer: CustomerDto;
    partNumberId: number;
    partNumber: PartNumberDto;
    unitPrice: number;
    currency: string | undefined;
    publishDate: moment.Moment;
    isActive: boolean;

    constructor(data?: IPartNumberPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? CustomerDto.fromJS(_data["customer"]) : <any>undefined;
            this.partNumberId = _data["partNumberId"];
            this.partNumber = _data["partNumber"] ? PartNumberDto.fromJS(_data["partNumber"]) : <any>undefined;
            this.unitPrice = _data["unitPrice"];
            this.currency = _data["currency"];
            this.publishDate = _data["publishDate"] ? moment(_data["publishDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PartNumberPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartNumberPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["partNumberId"] = this.partNumberId;
        data["partNumber"] = this.partNumber ? this.partNumber.toJSON() : <any>undefined;
        data["unitPrice"] = this.unitPrice;
        data["currency"] = this.currency;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PartNumberPriceDto {
        const json = this.toJSON();
        let result = new PartNumberPriceDto();
        result.init(json);
        return result;
    }
}

export interface IPartNumberPriceDto {
    id: number | undefined;
    customerId: number;
    customer: CustomerDto;
    partNumberId: number;
    partNumber: PartNumberDto;
    unitPrice: number;
    currency: string | undefined;
    publishDate: moment.Moment;
    isActive: boolean;
}

export class PartNumberPriceInternalDto implements IPartNumberPriceInternalDto {
    id: number | undefined;
    customerId: number | undefined;
    customer: CustomerDto;
    partNumberInternalId: number | undefined;
    partNumber: PartNumberDto;
    unitPrice: number;
    currency: string | undefined;
    publishDate: moment.Moment;
    isActive: boolean;

    constructor(data?: IPartNumberPriceInternalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? CustomerDto.fromJS(_data["customer"]) : <any>undefined;
            this.partNumberInternalId = _data["partNumberInternalId"];
            this.partNumber = _data["partNumber"] ? PartNumberDto.fromJS(_data["partNumber"]) : <any>undefined;
            this.unitPrice = _data["unitPrice"];
            this.currency = _data["currency"];
            this.publishDate = _data["publishDate"] ? moment(_data["publishDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PartNumberPriceInternalDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartNumberPriceInternalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["partNumberInternalId"] = this.partNumberInternalId;
        data["partNumber"] = this.partNumber ? this.partNumber.toJSON() : <any>undefined;
        data["unitPrice"] = this.unitPrice;
        data["currency"] = this.currency;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PartNumberPriceInternalDto {
        const json = this.toJSON();
        let result = new PartNumberPriceInternalDto();
        result.init(json);
        return result;
    }
}

export interface IPartNumberPriceInternalDto {
    id: number | undefined;
    customerId: number | undefined;
    customer: CustomerDto;
    partNumberInternalId: number | undefined;
    partNumber: PartNumberDto;
    unitPrice: number;
    currency: string | undefined;
    publishDate: moment.Moment;
    isActive: boolean;
}

export class PartNumberResXlsxDto implements IPartNumberResXlsxDto {
    processDate: moment.Moment;
    counter: number;
    counterDel: number;
    counterUpd: number;
    counterIns: number;

    constructor(data?: IPartNumberResXlsxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processDate = _data["processDate"] ? moment(_data["processDate"].toString()) : <any>undefined;
            this.counter = _data["counter"];
            this.counterDel = _data["counterDel"];
            this.counterUpd = _data["counterUpd"];
            this.counterIns = _data["counterIns"];
        }
    }

    static fromJS(data: any): PartNumberResXlsxDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartNumberResXlsxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDate"] = this.processDate ? this.processDate.toISOString() : <any>undefined;
        data["counter"] = this.counter;
        data["counterDel"] = this.counterDel;
        data["counterUpd"] = this.counterUpd;
        data["counterIns"] = this.counterIns;
        return data;
    }

    clone(): PartNumberResXlsxDto {
        const json = this.toJSON();
        let result = new PartNumberResXlsxDto();
        result.init(json);
        return result;
    }
}

export interface IPartNumberResXlsxDto {
    processDate: moment.Moment;
    counter: number;
    counterDel: number;
    counterUpd: number;
    counterIns: number;
}

export class PartNumberXlsxDto implements IPartNumberXlsxDto {
    partNumber: string | undefined;
    descriptionInglish: string | undefined;
    descriptionSpanish: string | undefined;
    unitMeasureId: number | undefined;
    productCodeSATId: number | undefined;
    weight: number | undefined;
    originCountryId: string | undefined;
    fraction: string | undefined;

    constructor(data?: IPartNumberXlsxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partNumber = _data["partNumber"];
            this.descriptionInglish = _data["descriptionInglish"];
            this.descriptionSpanish = _data["descriptionSpanish"];
            this.unitMeasureId = _data["unitMeasureId"];
            this.productCodeSATId = _data["productCodeSATId"];
            this.weight = _data["weight"];
            this.originCountryId = _data["originCountryId"];
            this.fraction = _data["fraction"];
        }
    }

    static fromJS(data: any): PartNumberXlsxDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartNumberXlsxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partNumber"] = this.partNumber;
        data["descriptionInglish"] = this.descriptionInglish;
        data["descriptionSpanish"] = this.descriptionSpanish;
        data["unitMeasureId"] = this.unitMeasureId;
        data["productCodeSATId"] = this.productCodeSATId;
        data["weight"] = this.weight;
        data["originCountryId"] = this.originCountryId;
        data["fraction"] = this.fraction;
        return data;
    }

    clone(): PartNumberXlsxDto {
        const json = this.toJSON();
        let result = new PartNumberXlsxDto();
        result.init(json);
        return result;
    }
}

export interface IPartNumberXlsxDto {
    partNumber: string | undefined;
    descriptionInglish: string | undefined;
    descriptionSpanish: string | undefined;
    unitMeasureId: number | undefined;
    productCodeSATId: number | undefined;
    weight: number | undefined;
    originCountryId: string | undefined;
    fraction: string | undefined;
}

export class PaymentStatus implements IPaymentStatus {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    code: string | undefined;
    name: string | undefined;

    constructor(data?: IPaymentStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PaymentStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }

    clone(): PaymentStatus {
        const json = this.toJSON();
        let result = new PaymentStatus();
        result.init(json);
        return result;
    }
}

export interface IPaymentStatus {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    code: string | undefined;
    name: string | undefined;
}

export class PaymentTermCarrierDto implements IPaymentTermCarrierDto {
    id: number | undefined;
    paymentTermId: number;
    carrierId: number;
    warningType: number;

    constructor(data?: IPaymentTermCarrierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentTermId = _data["paymentTermId"];
            this.carrierId = _data["carrierId"];
            this.warningType = _data["warningType"];
        }
    }

    static fromJS(data: any): PaymentTermCarrierDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentTermCarrierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentTermId"] = this.paymentTermId;
        data["carrierId"] = this.carrierId;
        data["warningType"] = this.warningType;
        return data;
    }

    clone(): PaymentTermCarrierDto {
        const json = this.toJSON();
        let result = new PaymentTermCarrierDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentTermCarrierDto {
    id: number | undefined;
    paymentTermId: number;
    carrierId: number;
    warningType: number;
}

export class PaymentTermDto implements IPaymentTermDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    alwaysDnmx: boolean;
    accountingApprovalRequired: boolean;
    excludeOnSamples: boolean;
    warning1CompanyIds: number[] | undefined;
    warning1Message: string | undefined;
    warning2CompanyIds: number[] | undefined;
    warning2Message: string | undefined;
    warning2Amount: number;
    poWarning: string | undefined;
    isActive: boolean;
    carriers: PaymentTermCarrierDto[] | undefined;

    constructor(data?: IPaymentTermDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.alwaysDnmx = _data["alwaysDnmx"];
            this.accountingApprovalRequired = _data["accountingApprovalRequired"];
            this.excludeOnSamples = _data["excludeOnSamples"];
            if (Array.isArray(_data["warning1CompanyIds"])) {
                this.warning1CompanyIds = [] as any;
                for (let item of _data["warning1CompanyIds"])
                    this.warning1CompanyIds.push(item);
            }
            this.warning1Message = _data["warning1Message"];
            if (Array.isArray(_data["warning2CompanyIds"])) {
                this.warning2CompanyIds = [] as any;
                for (let item of _data["warning2CompanyIds"])
                    this.warning2CompanyIds.push(item);
            }
            this.warning2Message = _data["warning2Message"];
            this.warning2Amount = _data["warning2Amount"];
            this.poWarning = _data["poWarning"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["carriers"])) {
                this.carriers = [] as any;
                for (let item of _data["carriers"])
                    this.carriers.push(PaymentTermCarrierDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentTermDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentTermDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["alwaysDnmx"] = this.alwaysDnmx;
        data["accountingApprovalRequired"] = this.accountingApprovalRequired;
        data["excludeOnSamples"] = this.excludeOnSamples;
        if (Array.isArray(this.warning1CompanyIds)) {
            data["warning1CompanyIds"] = [];
            for (let item of this.warning1CompanyIds)
                data["warning1CompanyIds"].push(item);
        }
        data["warning1Message"] = this.warning1Message;
        if (Array.isArray(this.warning2CompanyIds)) {
            data["warning2CompanyIds"] = [];
            for (let item of this.warning2CompanyIds)
                data["warning2CompanyIds"].push(item);
        }
        data["warning2Message"] = this.warning2Message;
        data["warning2Amount"] = this.warning2Amount;
        data["poWarning"] = this.poWarning;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.carriers)) {
            data["carriers"] = [];
            for (let item of this.carriers)
                data["carriers"].push(item.toJSON());
        }
        return data;
    }

    clone(): PaymentTermDto {
        const json = this.toJSON();
        let result = new PaymentTermDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentTermDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    alwaysDnmx: boolean;
    accountingApprovalRequired: boolean;
    excludeOnSamples: boolean;
    warning1CompanyIds: number[] | undefined;
    warning1Message: string | undefined;
    warning2CompanyIds: number[] | undefined;
    warning2Message: string | undefined;
    warning2Amount: number;
    poWarning: string | undefined;
    isActive: boolean;
    carriers: PaymentTermCarrierDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class PlantByUserDto implements IPlantByUserDto {
    plantId: number;
    plantName: string | undefined;
    userId: number;
    isSupervisor: boolean;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    addressLine4: string | undefined;
    rfc: string | undefined;

    constructor(data?: IPlantByUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plantId = _data["plantId"];
            this.plantName = _data["plantName"];
            this.userId = _data["userId"];
            this.isSupervisor = _data["isSupervisor"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.addressLine4 = _data["addressLine4"];
            this.rfc = _data["rfc"];
        }
    }

    static fromJS(data: any): PlantByUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlantByUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plantId"] = this.plantId;
        data["plantName"] = this.plantName;
        data["userId"] = this.userId;
        data["isSupervisor"] = this.isSupervisor;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["addressLine4"] = this.addressLine4;
        data["rfc"] = this.rfc;
        return data;
    }

    clone(): PlantByUserDto {
        const json = this.toJSON();
        let result = new PlantByUserDto();
        result.init(json);
        return result;
    }
}

export interface IPlantByUserDto {
    plantId: number;
    plantName: string | undefined;
    userId: number;
    isSupervisor: boolean;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    addressLine4: string | undefined;
    rfc: string | undefined;
}

export class PlantDto implements IPlantDto {
    id: number | undefined;
    name: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    addressLine4: string | undefined;
    rfc: string | undefined;
    sufix: string | undefined;
    isActive: boolean;
    totalUsers: number;
    fullName: string | undefined;

    constructor(data?: IPlantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.addressLine4 = _data["addressLine4"];
            this.rfc = _data["rfc"];
            this.sufix = _data["sufix"];
            this.isActive = _data["isActive"];
            this.totalUsers = _data["totalUsers"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): PlantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["addressLine4"] = this.addressLine4;
        data["rfc"] = this.rfc;
        data["sufix"] = this.sufix;
        data["isActive"] = this.isActive;
        data["totalUsers"] = this.totalUsers;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): PlantDto {
        const json = this.toJSON();
        let result = new PlantDto();
        result.init(json);
        return result;
    }
}

export interface IPlantDto {
    id: number | undefined;
    name: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    addressLine3: string | undefined;
    addressLine4: string | undefined;
    rfc: string | undefined;
    sufix: string | undefined;
    isActive: boolean;
    totalUsers: number;
    fullName: string | undefined;
}

export class PlantUserDto implements IPlantUserDto {
    id: number;
    plantId: number;
    isSupervisor: boolean;
    plantName: string | undefined;

    constructor(data?: IPlantUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.plantId = _data["plantId"];
            this.isSupervisor = _data["isSupervisor"];
            this.plantName = _data["plantName"];
        }
    }

    static fromJS(data: any): PlantUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlantUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["plantId"] = this.plantId;
        data["isSupervisor"] = this.isSupervisor;
        data["plantName"] = this.plantName;
        return data;
    }

    clone(): PlantUserDto {
        const json = this.toJSON();
        let result = new PlantUserDto();
        result.init(json);
        return result;
    }
}

export interface IPlantUserDto {
    id: number;
    plantId: number;
    isSupervisor: boolean;
    plantName: string | undefined;
}

export class ProductCodeSATDto implements IProductCodeSATDto {
    id: number | undefined;
    code: string | undefined;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: IProductCodeSATDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductCodeSATDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCodeSATDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ProductCodeSATDto {
        const json = this.toJSON();
        let result = new ProductCodeSATDto();
        result.init(json);
        return result;
    }
}

export interface IProductCodeSATDto {
    id: number | undefined;
    code: string | undefined;
    description: string | undefined;
    isActive: boolean;
}

export class PurchaseOrdersDto implements IPurchaseOrdersDto {
    id: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    purchaseOrder: string | undefined;
    line: number | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    qty: number | undefined;
    requiredDate: moment.Moment | undefined;
    statusId: number | undefined;
    ticket: string | undefined;

    constructor(data?: IPurchaseOrdersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.plannerCode = _data["plannerCode"];
            this.plannerName = _data["plannerName"];
            this.purchaseOrder = _data["purchaseOrder"];
            this.line = _data["line"];
            this.partNumber = _data["partNumber"];
            this.partDescription = _data["partDescription"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.qty = _data["qty"];
            this.requiredDate = _data["requiredDate"] ? moment(_data["requiredDate"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.ticket = _data["ticket"];
        }
    }

    static fromJS(data: any): PurchaseOrdersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrdersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["plannerCode"] = this.plannerCode;
        data["plannerName"] = this.plannerName;
        data["purchaseOrder"] = this.purchaseOrder;
        data["line"] = this.line;
        data["partNumber"] = this.partNumber;
        data["partDescription"] = this.partDescription;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["qty"] = this.qty;
        data["requiredDate"] = this.requiredDate ? this.requiredDate.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["ticket"] = this.ticket;
        return data;
    }

    clone(): PurchaseOrdersDto {
        const json = this.toJSON();
        let result = new PurchaseOrdersDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseOrdersDto {
    id: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    purchaseOrder: string | undefined;
    line: number | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    qty: number | undefined;
    requiredDate: moment.Moment | undefined;
    statusId: number | undefined;
    ticket: string | undefined;
}

export class PurchaseOrdersItemDto implements IPurchaseOrdersItemDto {
    purchaseOrderId: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    purchaseOrder: string | undefined;
    line: number | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    qty: number | undefined;
    requiredDate: moment.Moment | undefined;
    statusId: number | undefined;
    statusPO: string | undefined;
    ticket: string | undefined;
    creationDate: moment.Moment | undefined;

    constructor(data?: IPurchaseOrdersItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.plannerCode = _data["plannerCode"];
            this.plannerName = _data["plannerName"];
            this.purchaseOrder = _data["purchaseOrder"];
            this.line = _data["line"];
            this.partNumber = _data["partNumber"];
            this.partDescription = _data["partDescription"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.qty = _data["qty"];
            this.requiredDate = _data["requiredDate"] ? moment(_data["requiredDate"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.statusPO = _data["statusPO"];
            this.ticket = _data["ticket"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PurchaseOrdersItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrdersItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["plannerCode"] = this.plannerCode;
        data["plannerName"] = this.plannerName;
        data["purchaseOrder"] = this.purchaseOrder;
        data["line"] = this.line;
        data["partNumber"] = this.partNumber;
        data["partDescription"] = this.partDescription;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["qty"] = this.qty;
        data["requiredDate"] = this.requiredDate ? this.requiredDate.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["statusPO"] = this.statusPO;
        data["ticket"] = this.ticket;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): PurchaseOrdersItemDto {
        const json = this.toJSON();
        let result = new PurchaseOrdersItemDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseOrdersItemDto {
    purchaseOrderId: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    purchaseOrder: string | undefined;
    line: number | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    qty: number | undefined;
    requiredDate: moment.Moment | undefined;
    statusId: number | undefined;
    statusPO: string | undefined;
    ticket: string | undefined;
    creationDate: moment.Moment | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class RmaAssignmentDto implements IRmaAssignmentDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IRmaAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RmaAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RmaAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): RmaAssignmentDto {
        const json = this.toJSON();
        let result = new RmaAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IRmaAssignmentDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class RoleDto implements IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class SendRemindersInput implements ISendRemindersInput {
    notificationType: HotSheetNotificationType;
    userId: number | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    hotSheets: HotSheetReminderItem[] | undefined;

    constructor(data?: ISendRemindersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationType = _data["notificationType"];
            this.userId = _data["userId"];
            this.fullName = _data["fullName"];
            this.emailAddress = _data["emailAddress"];
            if (Array.isArray(_data["hotSheets"])) {
                this.hotSheets = [] as any;
                for (let item of _data["hotSheets"])
                    this.hotSheets.push(HotSheetReminderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendRemindersInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendRemindersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationType"] = this.notificationType;
        data["userId"] = this.userId;
        data["fullName"] = this.fullName;
        data["emailAddress"] = this.emailAddress;
        if (Array.isArray(this.hotSheets)) {
            data["hotSheets"] = [];
            for (let item of this.hotSheets)
                data["hotSheets"].push(item.toJSON());
        }
        return data;
    }

    clone(): SendRemindersInput {
        const json = this.toJSON();
        let result = new SendRemindersInput();
        result.init(json);
        return result;
    }
}

export interface ISendRemindersInput {
    notificationType: HotSheetNotificationType;
    userId: number | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    hotSheets: HotSheetReminderItem[] | undefined;
}

export class ServiceDto implements IServiceDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    isNational: boolean;
    isInternational: boolean;
    showHigestCostWarning: boolean;
    ground: boolean;
    air: boolean;
    sea: boolean;
    isActive: boolean;
    fullName: string | undefined;

    constructor(data?: IServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isNational = _data["isNational"];
            this.isInternational = _data["isInternational"];
            this.showHigestCostWarning = _data["showHigestCostWarning"];
            this.ground = _data["ground"];
            this.air = _data["air"];
            this.sea = _data["sea"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): ServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isNational"] = this.isNational;
        data["isInternational"] = this.isInternational;
        data["showHigestCostWarning"] = this.showHigestCostWarning;
        data["ground"] = this.ground;
        data["air"] = this.air;
        data["sea"] = this.sea;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): ServiceDto {
        const json = this.toJSON();
        let result = new ServiceDto();
        result.init(json);
        return result;
    }
}

export interface IServiceDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    isNational: boolean;
    isInternational: boolean;
    showHigestCostWarning: boolean;
    ground: boolean;
    air: boolean;
    sea: boolean;
    isActive: boolean;
    fullName: string | undefined;
}

export class SettingsParametersDto implements ISettingsParametersDto {
    id: number | undefined;
    tenantId: number | undefined;
    name: string | undefined;
    value: string | undefined;

    constructor(data?: ISettingsParametersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SettingsParametersDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsParametersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): SettingsParametersDto {
        const json = this.toJSON();
        let result = new SettingsParametersDto();
        result.init(json);
        return result;
    }
}

export interface ISettingsParametersDto {
    id: number | undefined;
    tenantId: number | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class ShortageShiftDto implements IShortageShiftDto {
    id: number | undefined;
    code: string | undefined;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: IShortageShiftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ShortageShiftDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShortageShiftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ShortageShiftDto {
        const json = this.toJSON();
        let result = new ShortageShiftDto();
        result.init(json);
        return result;
    }
}

export interface IShortageShiftDto {
    id: number | undefined;
    code: string | undefined;
    description: string | undefined;
    isActive: boolean;
}

export class SpecialExpeditedReasonDto implements ISpecialExpeditedReasonDto {
    id: number | undefined;
    reason: string | undefined;
    isActive: boolean;

    constructor(data?: ISpecialExpeditedReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reason = _data["reason"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SpecialExpeditedReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialExpeditedReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reason"] = this.reason;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): SpecialExpeditedReasonDto {
        const json = this.toJSON();
        let result = new SpecialExpeditedReasonDto();
        result.init(json);
        return result;
    }
}

export interface ISpecialExpeditedReasonDto {
    id: number | undefined;
    reason: string | undefined;
    isActive: boolean;
}

export class StaffDto implements IStaffDto {
    id: number | undefined;
    userId: number;
    user: UserBasicDto;
    type: number;
    isActive: boolean;

    constructor(data?: IStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserBasicDto.fromJS(_data["user"]) : <any>undefined;
            this.type = _data["type"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): StaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): StaffDto {
        const json = this.toJSON();
        let result = new StaffDto();
        result.init(json);
        return result;
    }
}

export interface IStaffDto {
    id: number | undefined;
    userId: number;
    user: UserBasicDto;
    type: number;
    isActive: boolean;
}

export class StarSheetsCommetsDto implements IStarSheetsCommetsDto {
    id: number | undefined;
    starSheetId: number;
    departmentId: number;
    department: string | undefined;
    comments: string | undefined;
    creatorUserId: number;
    creationTime: moment.Moment | undefined;
    creatorFullName: string | undefined;

    constructor(data?: IStarSheetsCommetsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.starSheetId = _data["starSheetId"];
            this.departmentId = _data["departmentId"];
            this.department = _data["department"];
            this.comments = _data["comments"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorFullName = _data["creatorFullName"];
        }
    }

    static fromJS(data: any): StarSheetsCommetsDto {
        data = typeof data === 'object' ? data : {};
        let result = new StarSheetsCommetsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["starSheetId"] = this.starSheetId;
        data["departmentId"] = this.departmentId;
        data["department"] = this.department;
        data["comments"] = this.comments;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorFullName"] = this.creatorFullName;
        return data;
    }

    clone(): StarSheetsCommetsDto {
        const json = this.toJSON();
        let result = new StarSheetsCommetsDto();
        result.init(json);
        return result;
    }
}

export interface IStarSheetsCommetsDto {
    id: number | undefined;
    starSheetId: number;
    departmentId: number;
    department: string | undefined;
    comments: string | undefined;
    creatorUserId: number;
    creationTime: moment.Moment | undefined;
    creatorFullName: string | undefined;
}

export class StarSheetsDto implements IStarSheetsDto {
    id: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number | undefined;
    diaStockIn: number | undefined;
    diaLocation: string | undefined;
    cigmaReceived: number | undefined;
    transportModeId: number | undefined;
    transportMode: TransportModeDto;
    deliveryOrder: number | undefined;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheet: StatusHotSheetDto;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShift: ShortageShiftDto;
    shortage: string | undefined;
    asn: number;
    pcComments: string | undefined;

    constructor(data?: IStarSheetsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.plannerCode = _data["plannerCode"];
            this.plannerName = _data["plannerName"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.partNumber = _data["partNumber"];
            this.partDescription = _data["partDescription"];
            this.inTransitQty = _data["inTransitQty"];
            this.diaStockIn = _data["diaStockIn"];
            this.diaLocation = _data["diaLocation"];
            this.cigmaReceived = _data["cigmaReceived"];
            this.transportModeId = _data["transportModeId"];
            this.transportMode = _data["transportMode"] ? TransportModeDto.fromJS(_data["transportMode"]) : <any>undefined;
            this.deliveryOrder = _data["deliveryOrder"];
            this.trafficContainerFX = _data["trafficContainerFX"];
            this.unitNumber = _data["unitNumber"];
            this.etaDNMX = _data["etaDNMX"] ? moment(_data["etaDNMX"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.statusHotSheet = _data["statusHotSheet"] ? StatusHotSheetDto.fromJS(_data["statusHotSheet"]) : <any>undefined;
            this.realShortageDate = _data["realShortageDate"] ? moment(_data["realShortageDate"].toString()) : <any>undefined;
            this.shortageShiftId = _data["shortageShiftId"];
            this.shortageShift = _data["shortageShift"] ? ShortageShiftDto.fromJS(_data["shortageShift"]) : <any>undefined;
            this.shortage = _data["shortage"];
            this.asn = _data["asn"];
            this.pcComments = _data["pcComments"];
        }
    }

    static fromJS(data: any): StarSheetsDto {
        data = typeof data === 'object' ? data : {};
        let result = new StarSheetsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["plannerCode"] = this.plannerCode;
        data["plannerName"] = this.plannerName;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["partNumber"] = this.partNumber;
        data["partDescription"] = this.partDescription;
        data["inTransitQty"] = this.inTransitQty;
        data["diaStockIn"] = this.diaStockIn;
        data["diaLocation"] = this.diaLocation;
        data["cigmaReceived"] = this.cigmaReceived;
        data["transportModeId"] = this.transportModeId;
        data["transportMode"] = this.transportMode ? this.transportMode.toJSON() : <any>undefined;
        data["deliveryOrder"] = this.deliveryOrder;
        data["trafficContainerFX"] = this.trafficContainerFX;
        data["unitNumber"] = this.unitNumber;
        data["etaDNMX"] = this.etaDNMX ? this.etaDNMX.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["statusHotSheet"] = this.statusHotSheet ? this.statusHotSheet.toJSON() : <any>undefined;
        data["realShortageDate"] = this.realShortageDate ? this.realShortageDate.toISOString() : <any>undefined;
        data["shortageShiftId"] = this.shortageShiftId;
        data["shortageShift"] = this.shortageShift ? this.shortageShift.toJSON() : <any>undefined;
        data["shortage"] = this.shortage;
        data["asn"] = this.asn;
        data["pcComments"] = this.pcComments;
        return data;
    }

    clone(): StarSheetsDto {
        const json = this.toJSON();
        let result = new StarSheetsDto();
        result.init(json);
        return result;
    }
}

export interface IStarSheetsDto {
    id: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number | undefined;
    diaStockIn: number | undefined;
    diaLocation: string | undefined;
    cigmaReceived: number | undefined;
    transportModeId: number | undefined;
    transportMode: TransportModeDto;
    deliveryOrder: number | undefined;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheet: StatusHotSheetDto;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShift: ShortageShiftDto;
    shortage: string | undefined;
    asn: number;
    pcComments: string | undefined;
}

export class StarSheetsItemDetailDto implements IStarSheetsItemDetailDto {
    starSheetId: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplerName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number;
    diaStockIn: number;
    diaLocation: string | undefined;
    cigmaReceived: number;
    transportModeId: number | undefined;
    transportModeName: string | undefined;
    deliveryOrder: number;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheetName: string | undefined;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShiftName: string | undefined;
    shortage: string | undefined;
    shortageVal: string | undefined;
    pcComments: string | undefined;
    files: FileDto[] | undefined;

    constructor(data?: IStarSheetsItemDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.starSheetId = _data["starSheetId"];
            this.plannerCode = _data["plannerCode"];
            this.plannerName = _data["plannerName"];
            this.supplierCode = _data["supplierCode"];
            this.supplerName = _data["supplerName"];
            this.partNumber = _data["partNumber"];
            this.partDescription = _data["partDescription"];
            this.inTransitQty = _data["inTransitQty"];
            this.diaStockIn = _data["diaStockIn"];
            this.diaLocation = _data["diaLocation"];
            this.cigmaReceived = _data["cigmaReceived"];
            this.transportModeId = _data["transportModeId"];
            this.transportModeName = _data["transportModeName"];
            this.deliveryOrder = _data["deliveryOrder"];
            this.trafficContainerFX = _data["trafficContainerFX"];
            this.unitNumber = _data["unitNumber"];
            this.etaDNMX = _data["etaDNMX"] ? moment(_data["etaDNMX"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.statusHotSheetName = _data["statusHotSheetName"];
            this.realShortageDate = _data["realShortageDate"] ? moment(_data["realShortageDate"].toString()) : <any>undefined;
            this.shortageShiftId = _data["shortageShiftId"];
            this.shortageShiftName = _data["shortageShiftName"];
            this.shortage = _data["shortage"];
            this.shortageVal = _data["shortageVal"];
            this.pcComments = _data["pcComments"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files.push(FileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StarSheetsItemDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new StarSheetsItemDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["starSheetId"] = this.starSheetId;
        data["plannerCode"] = this.plannerCode;
        data["plannerName"] = this.plannerName;
        data["supplierCode"] = this.supplierCode;
        data["supplerName"] = this.supplerName;
        data["partNumber"] = this.partNumber;
        data["partDescription"] = this.partDescription;
        data["inTransitQty"] = this.inTransitQty;
        data["diaStockIn"] = this.diaStockIn;
        data["diaLocation"] = this.diaLocation;
        data["cigmaReceived"] = this.cigmaReceived;
        data["transportModeId"] = this.transportModeId;
        data["transportModeName"] = this.transportModeName;
        data["deliveryOrder"] = this.deliveryOrder;
        data["trafficContainerFX"] = this.trafficContainerFX;
        data["unitNumber"] = this.unitNumber;
        data["etaDNMX"] = this.etaDNMX ? this.etaDNMX.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["statusHotSheetName"] = this.statusHotSheetName;
        data["realShortageDate"] = this.realShortageDate ? this.realShortageDate.toISOString() : <any>undefined;
        data["shortageShiftId"] = this.shortageShiftId;
        data["shortageShiftName"] = this.shortageShiftName;
        data["shortage"] = this.shortage;
        data["shortageVal"] = this.shortageVal;
        data["pcComments"] = this.pcComments;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }

    clone(): StarSheetsItemDetailDto {
        const json = this.toJSON();
        let result = new StarSheetsItemDetailDto();
        result.init(json);
        return result;
    }
}

export interface IStarSheetsItemDetailDto {
    starSheetId: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplerName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number;
    diaStockIn: number;
    diaLocation: string | undefined;
    cigmaReceived: number;
    transportModeId: number | undefined;
    transportModeName: string | undefined;
    deliveryOrder: number;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheetName: string | undefined;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShiftName: string | undefined;
    shortage: string | undefined;
    shortageVal: string | undefined;
    pcComments: string | undefined;
    files: FileDto[] | undefined;
}

export class StarSheetsItemDto implements IStarSheetsItemDto {
    starSheetId: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number;
    diaStockIn: number;
    diaLocation: string | undefined;
    cigmaReceived: number;
    transportModeId: number | undefined;
    transportModeName: string | undefined;
    deliveryOrder: number;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheetName: string | undefined;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShiftName: string | undefined;
    shortage: string | undefined;
    shortageVal: string | undefined;
    asn: string | undefined;
    pcComments: string | undefined;
    creationDate: moment.Moment | undefined;
    existComment: number;

    constructor(data?: IStarSheetsItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.starSheetId = _data["starSheetId"];
            this.plannerCode = _data["plannerCode"];
            this.plannerName = _data["plannerName"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.partNumber = _data["partNumber"];
            this.partDescription = _data["partDescription"];
            this.inTransitQty = _data["inTransitQty"];
            this.diaStockIn = _data["diaStockIn"];
            this.diaLocation = _data["diaLocation"];
            this.cigmaReceived = _data["cigmaReceived"];
            this.transportModeId = _data["transportModeId"];
            this.transportModeName = _data["transportModeName"];
            this.deliveryOrder = _data["deliveryOrder"];
            this.trafficContainerFX = _data["trafficContainerFX"];
            this.unitNumber = _data["unitNumber"];
            this.etaDNMX = _data["etaDNMX"] ? moment(_data["etaDNMX"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.statusHotSheetName = _data["statusHotSheetName"];
            this.realShortageDate = _data["realShortageDate"] ? moment(_data["realShortageDate"].toString()) : <any>undefined;
            this.shortageShiftId = _data["shortageShiftId"];
            this.shortageShiftName = _data["shortageShiftName"];
            this.shortage = _data["shortage"];
            this.shortageVal = _data["shortageVal"];
            this.asn = _data["asn"];
            this.pcComments = _data["pcComments"];
            this.creationDate = _data["creationDate"] ? moment(_data["creationDate"].toString()) : <any>undefined;
            this.existComment = _data["existComment"];
        }
    }

    static fromJS(data: any): StarSheetsItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new StarSheetsItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["starSheetId"] = this.starSheetId;
        data["plannerCode"] = this.plannerCode;
        data["plannerName"] = this.plannerName;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["partNumber"] = this.partNumber;
        data["partDescription"] = this.partDescription;
        data["inTransitQty"] = this.inTransitQty;
        data["diaStockIn"] = this.diaStockIn;
        data["diaLocation"] = this.diaLocation;
        data["cigmaReceived"] = this.cigmaReceived;
        data["transportModeId"] = this.transportModeId;
        data["transportModeName"] = this.transportModeName;
        data["deliveryOrder"] = this.deliveryOrder;
        data["trafficContainerFX"] = this.trafficContainerFX;
        data["unitNumber"] = this.unitNumber;
        data["etaDNMX"] = this.etaDNMX ? this.etaDNMX.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["statusHotSheetName"] = this.statusHotSheetName;
        data["realShortageDate"] = this.realShortageDate ? this.realShortageDate.toISOString() : <any>undefined;
        data["shortageShiftId"] = this.shortageShiftId;
        data["shortageShiftName"] = this.shortageShiftName;
        data["shortage"] = this.shortage;
        data["shortageVal"] = this.shortageVal;
        data["asn"] = this.asn;
        data["pcComments"] = this.pcComments;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["existComment"] = this.existComment;
        return data;
    }

    clone(): StarSheetsItemDto {
        const json = this.toJSON();
        let result = new StarSheetsItemDto();
        result.init(json);
        return result;
    }
}

export interface IStarSheetsItemDto {
    starSheetId: number | undefined;
    plannerCode: string | undefined;
    plannerName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    partNumber: string | undefined;
    partDescription: string | undefined;
    inTransitQty: number;
    diaStockIn: number;
    diaLocation: string | undefined;
    cigmaReceived: number;
    transportModeId: number | undefined;
    transportModeName: string | undefined;
    deliveryOrder: number;
    trafficContainerFX: string | undefined;
    unitNumber: string | undefined;
    etaDNMX: moment.Moment | undefined;
    statusId: number | undefined;
    statusHotSheetName: string | undefined;
    realShortageDate: moment.Moment | undefined;
    shortageShiftId: number | undefined;
    shortageShiftName: string | undefined;
    shortage: string | undefined;
    shortageVal: string | undefined;
    asn: string | undefined;
    pcComments: string | undefined;
    creationDate: moment.Moment | undefined;
    existComment: number;
}

export class StatusHotSheetDto implements IStatusHotSheetDto {
    id: number | undefined;
    code: string | undefined;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: IStatusHotSheetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): StatusHotSheetDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatusHotSheetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): StatusHotSheetDto {
        const json = this.toJSON();
        let result = new StatusHotSheetDto();
        result.init(json);
        return result;
    }
}

export interface IStatusHotSheetDto {
    id: number | undefined;
    code: string | undefined;
    description: string | undefined;
    isActive: boolean;
}

export class SurveyDto implements ISurveyDto {
    id: number | undefined;
    page: string | undefined;
    answerQuestion1: string | undefined;
    answerQuestion2: string | undefined;
    answerQuestion3: string | undefined;
    answerQuestion4: string | undefined;
    answerQuestion5: string | undefined;
    answerQuestion6: string | undefined;
    answerQuestion7: string | undefined;
    hotSheetShipId: number | undefined;
    hotSheetShipFolio: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number;
    creatorFullName: string | undefined;

    constructor(data?: ISurveyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.page = _data["page"];
            this.answerQuestion1 = _data["answerQuestion1"];
            this.answerQuestion2 = _data["answerQuestion2"];
            this.answerQuestion3 = _data["answerQuestion3"];
            this.answerQuestion4 = _data["answerQuestion4"];
            this.answerQuestion5 = _data["answerQuestion5"];
            this.answerQuestion6 = _data["answerQuestion6"];
            this.answerQuestion7 = _data["answerQuestion7"];
            this.hotSheetShipId = _data["hotSheetShipId"];
            this.hotSheetShipFolio = _data["hotSheetShipFolio"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.creatorFullName = _data["creatorFullName"];
        }
    }

    static fromJS(data: any): SurveyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["page"] = this.page;
        data["answerQuestion1"] = this.answerQuestion1;
        data["answerQuestion2"] = this.answerQuestion2;
        data["answerQuestion3"] = this.answerQuestion3;
        data["answerQuestion4"] = this.answerQuestion4;
        data["answerQuestion5"] = this.answerQuestion5;
        data["answerQuestion6"] = this.answerQuestion6;
        data["answerQuestion7"] = this.answerQuestion7;
        data["hotSheetShipId"] = this.hotSheetShipId;
        data["hotSheetShipFolio"] = this.hotSheetShipFolio;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorFullName"] = this.creatorFullName;
        return data;
    }

    clone(): SurveyDto {
        const json = this.toJSON();
        let result = new SurveyDto();
        result.init(json);
        return result;
    }
}

export interface ISurveyDto {
    id: number | undefined;
    page: string | undefined;
    answerQuestion1: string | undefined;
    answerQuestion2: string | undefined;
    answerQuestion3: string | undefined;
    answerQuestion4: string | undefined;
    answerQuestion5: string | undefined;
    answerQuestion6: string | undefined;
    answerQuestion7: string | undefined;
    hotSheetShipId: number | undefined;
    hotSheetShipFolio: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number;
    creatorFullName: string | undefined;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantDto implements ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
    useHostDefaultEmailSettings: boolean;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
            this.useHostDefaultEmailSettings = _data["useHostDefaultEmailSettings"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        return data;
    }

    clone(): TenantEmailSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantEmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
    useHostDefaultEmailSettings: boolean;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    email: TenantEmailSettingsEditDto;
    denso: DensoSettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] ? TenantEmailSettingsEditDto.fromJS(_data["email"]) : <any>undefined;
            this.denso = _data["denso"] ? DensoSettingsEditDto.fromJS(_data["denso"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["denso"] = this.denso ? this.denso.toJSON() : <any>undefined;
        return data;
    }

    clone(): TenantSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantSettingsEditDto {
    email: TenantEmailSettingsEditDto;
    denso: DensoSettingsEditDto;
}

export class TransportModeDto implements ITransportModeDto {
    id: number | undefined;
    code: string | undefined;
    description: string | undefined;
    isActive: boolean;

    constructor(data?: ITransportModeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TransportModeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportModeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): TransportModeDto {
        const json = this.toJSON();
        let result = new TransportModeDto();
        result.init(json);
        return result;
    }
}

export interface ITransportModeDto {
    id: number | undefined;
    code: string | undefined;
    description: string | undefined;
    isActive: boolean;
}

export class UnitMeasureDto implements IUnitMeasureDto {
    id: number | undefined;
    name: string | undefined;
    densoCode: string | undefined;
    satCode: string | undefined;
    segroveCode: string | undefined;
    isActive: boolean;
    fullName: string | undefined;

    constructor(data?: IUnitMeasureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.densoCode = _data["densoCode"];
            this.satCode = _data["satCode"];
            this.segroveCode = _data["segroveCode"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): UnitMeasureDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitMeasureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["densoCode"] = this.densoCode;
        data["satCode"] = this.satCode;
        data["segroveCode"] = this.segroveCode;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        return data;
    }

    clone(): UnitMeasureDto {
        const json = this.toJSON();
        let result = new UnitMeasureDto();
        result.init(json);
        return result;
    }
}

export interface IUnitMeasureDto {
    id: number | undefined;
    name: string | undefined;
    densoCode: string | undefined;
    satCode: string | undefined;
    segroveCode: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
}

export class UserBasicDto implements IUserBasicDto {
    id: number;
    userName: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
    employeeId: number | undefined;
    densoFullName: string | undefined;

    constructor(data?: IUserBasicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.employeeId = _data["employeeId"];
            this.densoFullName = _data["densoFullName"];
        }
    }

    static fromJS(data: any): UserBasicDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserBasicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["employeeId"] = this.employeeId;
        data["densoFullName"] = this.densoFullName;
        return data;
    }

    clone(): UserBasicDto {
        const json = this.toJSON();
        let result = new UserBasicDto();
        result.init(json);
        return result;
    }
}

export interface IUserBasicDto {
    id: number;
    userName: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    fullName: string | undefined;
    employeeId: number | undefined;
    densoFullName: string | undefined;
}

export class UserByCurrentUserDto implements IUserByCurrentUserDto {
    userId: number;
    fullName: string | undefined;
    departmentIds: string | undefined;

    constructor(data?: IUserByCurrentUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.fullName = _data["fullName"];
            this.departmentIds = _data["departmentIds"];
        }
    }

    static fromJS(data: any): UserByCurrentUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserByCurrentUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["fullName"] = this.fullName;
        data["departmentIds"] = this.departmentIds;
        return data;
    }

    clone(): UserByCurrentUserDto {
        const json = this.toJSON();
        let result = new UserByCurrentUserDto();
        result.init(json);
        return result;
    }
}

export interface IUserByCurrentUserDto {
    userId: number;
    fullName: string | undefined;
    departmentIds: string | undefined;
}

export class UserDto implements IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    departmentIds: number[] | undefined;
    plantIds: number[] | undefined;
    departments: DepartmentUserDto[] | undefined;
    plants: PlantUserDto[] | undefined;
    employeeId: number | undefined;
    densoEmployeeId: number | undefined;
    densoFullName: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            if (Array.isArray(_data["departmentIds"])) {
                this.departmentIds = [] as any;
                for (let item of _data["departmentIds"])
                    this.departmentIds.push(item);
            }
            if (Array.isArray(_data["plantIds"])) {
                this.plantIds = [] as any;
                for (let item of _data["plantIds"])
                    this.plantIds.push(item);
            }
            if (Array.isArray(_data["departments"])) {
                this.departments = [] as any;
                for (let item of _data["departments"])
                    this.departments.push(DepartmentUserDto.fromJS(item));
            }
            if (Array.isArray(_data["plants"])) {
                this.plants = [] as any;
                for (let item of _data["plants"])
                    this.plants.push(PlantUserDto.fromJS(item));
            }
            this.employeeId = _data["employeeId"];
            this.densoEmployeeId = _data["densoEmployeeId"];
            this.densoFullName = _data["densoFullName"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.departmentIds)) {
            data["departmentIds"] = [];
            for (let item of this.departmentIds)
                data["departmentIds"].push(item);
        }
        if (Array.isArray(this.plantIds)) {
            data["plantIds"] = [];
            for (let item of this.plantIds)
                data["plantIds"].push(item);
        }
        if (Array.isArray(this.departments)) {
            data["departments"] = [];
            for (let item of this.departments)
                data["departments"].push(item.toJSON());
        }
        if (Array.isArray(this.plants)) {
            data["plants"] = [];
            for (let item of this.plants)
                data["plants"].push(item.toJSON());
        }
        data["employeeId"] = this.employeeId;
        data["densoEmployeeId"] = this.densoEmployeeId;
        data["densoFullName"] = this.densoFullName;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    departmentIds: number[] | undefined;
    plantIds: number[] | undefined;
    departments: DepartmentUserDto[] | undefined;
    plants: PlantUserDto[] | undefined;
    employeeId: number | undefined;
    densoEmployeeId: number | undefined;
    densoFullName: string | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    plants: BasePlantDto[] | undefined;
    departments: BaseDepartmentDto[] | undefined;
    isAdmin: boolean;
    isImpoExpo: boolean;
    isPC: boolean;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            if (Array.isArray(_data["plants"])) {
                this.plants = [] as any;
                for (let item of _data["plants"])
                    this.plants.push(BasePlantDto.fromJS(item));
            }
            if (Array.isArray(_data["departments"])) {
                this.departments = [] as any;
                for (let item of _data["departments"])
                    this.departments.push(BaseDepartmentDto.fromJS(item));
            }
            this.isAdmin = _data["isAdmin"];
            this.isImpoExpo = _data["isImpoExpo"];
            this.isPC = _data["isPC"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        if (Array.isArray(this.plants)) {
            data["plants"] = [];
            for (let item of this.plants)
                data["plants"].push(item.toJSON());
        }
        if (Array.isArray(this.departments)) {
            data["departments"] = [];
            for (let item of this.departments)
                data["departments"].push(item.toJSON());
        }
        data["isAdmin"] = this.isAdmin;
        data["isImpoExpo"] = this.isImpoExpo;
        data["isPC"] = this.isPC;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    plants: BasePlantDto[] | undefined;
    departments: BaseDepartmentDto[] | undefined;
    isAdmin: boolean;
    isImpoExpo: boolean;
    isPC: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}